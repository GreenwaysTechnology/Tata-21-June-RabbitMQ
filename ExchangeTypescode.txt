Round Robin:

-By default, RabbitMQ will send each message to the next consumer, in sequence. On average every consumer will get the same number of messages. This way of distributing messages is called round-robin

Message Ack:

In order to make sure a message is never lost, RabbitMQ supports message acknowledgments. An acknowledgement is sent back by the consumer to tell RabbitMQ that a particular message has been received, processed and that RabbitMQ is free to delete it.

If a consumer dies (its channel is closed, connection is closed, or TCP connection is lost) without sending an ack, RabbitMQ will understand that a message wasn't processed fully and will re-queue it. If there are other consumers online at the same time, it will then quickly redeliver it to another consumer. That way you can be sure that no message is lost, even if the workers occasionally die.

Message Durability:
..................

We have learned how to make sure that even if the consumer dies, the task isn't lost. But our tasks will still be lost if RabbitMQ server stops.

When RabbitMQ quits or crashes it will forget the queues and messages unless you tell it not to. Two things are required to make sure that messages aren't lost: we need to mark both the queue and messages as durable.

First, we need to make sure that the queue will survive a RabbitMQ node restart. In order to do so, we need to declare it as durable:
boolean durable = true;
channel.queueDeclare("hello", durable, false, false, null);

Although this command is correct by itself, it won't work in our present setup. That's because we've already defined a queue called hello which is not durable. RabbitMQ doesn't allow you to redefine an existing queue with different parameters and will return an error to any program that tries to do that. But there is a quick workaround - let's declare a queue with different name

Message Durability:
...................

channel.basicPublish("", "task_queue",
            MessageProperties.PERSISTENT_TEXT_PLAIN,
            message.getBytes());


Marking messages as persistent doesn't fully guarantee that a message won't be lost. Although it tells RabbitMQ to save the message to disk, there is still a short time window when RabbitMQ has accepted a message and hasn't saved it yet. Also, RabbitMQ doesn't do fsync(2) for every message -- it may be just saved to cache and not really written to the disk. The persistence guarantees aren't strong, but it's more than enough for our simple task queue. If you need a stronger guarantee then you can use publisher confirms.


Fair Dispatch:

int prefetchCount = 1;
channel.basicQos(prefetchCount);

the basicQos method with the prefetchCount = 1 setting. This tells RabbitMQ not to give more than one message to a worker at a time. Or, in other words, don't dispatch a new message to a worker until it has processed and acknowledged the previous one. Instead, it will dispatch it to the next worker that is not still busy.
///////////////////////////////////////////////////////////////////////////////////////////

Exchange Types:

Direct Exchange

Direct Exchange :- A direct exchange routes messages to queues based on message routing key. The routing key is a message attribute in the message header added by the producer. The default exchange for direct exchange is “amq.direct“. For detailed explanation and code example, you can visit RabbitMQ – Direct Exchange.

eg:
1.one exchange
2.three queue
3.three routing key
package com.tata.exchange;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.tata.ExchangeType;
import com.tata.RabbitMQConnection;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class DirectProducer {
    public static String EXCHANGE_NAME = "direct-exchange";
    public static String QUEUE_NAME_1 = "direct-queue-1";
    public static String QUEUE_NAME_2 = "direct-queue-2";
    public static String QUEUE_NAME_3 = "direct-queue-3";

    public static String ROUTING_KEY_1 = "direct-key-1";
    public static String ROUTING_KEY_2 = "direct-key-2";
    public static String ROUTING_KEY_3 = "direct-key-3";

    private final static String MESSAGE_1 = "First Direct Message Example";
    private final static String MESSAGE_2 = "Second Direct Message Example";
    private final static String MESSAGE_3 = "Third Direct Message Example";

    public static void main(String[] args) {
        try{
            Connection conn = RabbitMQConnection.getConnection();
            if(conn != null){
                Channel channel = conn.createChannel();
                channel.exchangeDeclare(EXCHANGE_NAME, ExchangeType.DIRECT.getExchangeName(), true);
                // First Queue
                channel.queueDeclare(QUEUE_NAME_1, true, false, false, null);
                channel.queueBind(QUEUE_NAME_1, EXCHANGE_NAME, ROUTING_KEY_1);

                // Second Queue
                channel.queueDeclare(QUEUE_NAME_2, true, false, false, null);
                channel.queueBind(QUEUE_NAME_2, EXCHANGE_NAME, ROUTING_KEY_2);

                // Third Queue
                channel.queueDeclare(QUEUE_NAME_3, true, false, false, null);
                channel.queueBind(QUEUE_NAME_3, EXCHANGE_NAME, ROUTING_KEY_3);

                // First message sent by using ROUTING_KEY_1
                channel.basicPublish(DirectProducer.EXCHANGE_NAME, DirectProducer.ROUTING_KEY_1, null, MESSAGE_1.getBytes());
                System.out.println(" Message Sent '" + MESSAGE_1 + "'");

                // Second message sent by using ROUTING_KEY_2
                channel.basicPublish(DirectProducer.EXCHANGE_NAME, DirectProducer.ROUTING_KEY_2, null, MESSAGE_2.getBytes());
                System.out.println(" Message Sent '" + MESSAGE_2 + "'");

                // Third message sent by using ROUTING_KEY_3
                channel.basicPublish(DirectProducer.EXCHANGE_NAME, DirectProducer.ROUTING_KEY_3, null, MESSAGE_3.getBytes());
                System.out.println(" Message Sent '" + MESSAGE_3 + "'");
                channel.close();
                conn.close();
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}

package com.tata.exchange;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;
import com.tata.RabbitMQConnection;

public class DirectConsumer {
    public static void main(String[] args) {
        new DirectConsumer().receive();
    }

    public void receive() {
        try {
            Connection conn = RabbitMQConnection.getConnection();
            if (conn != null) {
                Channel channel = conn.createChannel();
                // Consumer reading from queue 1
//                Consumer consumer1 = new DefaultConsumer(channel) {
//                    @Override
//                    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
//                        String message = new String(body, "UTF-8");
//                        System.out.println(" Message Received Queue 1 '" + message + "'");
//                    }
//                };
                DeliverCallback consumer1 = (consumerTag, delivery) -> {
                    String message = new String(delivery.getBody(), "UTF-8");
                    System.out.println(" Message Received Queue 1 '" + message + "'");
                };
                channel.basicConsume(DirectProducer.QUEUE_NAME_1, true, consumer1, consumerTag -> {
                });

                // Consumer reading from queue 2
//                Consumer consumer2 = new DefaultConsumer(channel) {
//                    @Override
//                    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
//                        String message = new String(body, "UTF-8");
//                        System.out.println(" Message Received Queue 2 '" + message + "'");
//                    }
//                };
                DeliverCallback consumer2 = (consumerTag, delivery) -> {
                    String message = new String(delivery.getBody(), "UTF-8");
                    System.out.println(" Message Received Queue 2 '" + message + "'");
                };
                channel.basicConsume(DirectProducer.QUEUE_NAME_2, true, consumer2, consumerTag -> {
                });

                // Consumer reading from queue 3
//                Consumer consumer3 = new DefaultConsumer(channel) {
//                    @Override
//                    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
//                        String message = new String(body, "UTF-8");
//                        System.out.println(" Message Received Queue 3 '" + message + "'");
//                    }
//                };
                DeliverCallback consumer3 = (consumerTag, delivery) -> {
                    String message = new String(delivery.getBody(), "UTF-8");
                    System.out.println(" Message Received Queue 2 '" + message + "'");
                };
                channel.basicConsume(DirectProducer.QUEUE_NAME_3, true, consumer3, consumerTag -> {
                });
                Thread.sleep(5000);
                channel.close();
                conn.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
.............................................................................................
Topic Exchange :- A topic exchange route messages to queues based on the wildcard match between routing key and routing pattern specified during the binding of the queue. The default exchange for topic exchange is “amq.topic“.

Topic Exchange :- A topic exchange is an exchange which route messages to queues based on the wildcard match between routing key and routing pattern specified during the binding of the queue. Producer adds routing key in message header and sends it to topic exchange. After receiving a message, exchange try to match the routing key with the binding routing pattern of all the queues bound to it. If match is found, it route the message to the queue whose routing pattern is matched and if match is not found, it ignored the message.

Routing key :- It is the list of words, delimited by a period (.), for example “asia.china.beijing”

Routing Pattern :- It is the pattern, which is specified during the binding of the queue, it is the list of words and wildcard characters like “*” and “#“, delimited by a period (.). The use of wildcard characters are as follows :-

“*” :-  It is used to match a word at a specific position in the routing key, for example a routing pattern of “asia.china.*” will match to the routing keys where first word is “asia” and the second word is “china” like, “asia.china.beijing” and “asia.china.nanjing”.

“#” :- It is used to match zero or more words, for example a routing pattern of “asia.china.#” will match to the routing keys that begin with “asia.china” like, “asia.china” and “asia.china.beijing”.

https://codedestine.com/rabbitmq-topic-exchange/


eg:
package com.tata.exchange.topic;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.ExchangeType;
import com.tata.RabbitMQConnection;

public class TopicExchange {
    public static String EXCHANGE_NAME = "topic-exchange";
    public static String QUEUE_NAME_1 = "topic-queue-1";
    public static String QUEUE_NAME_2 = "topic-queue-2";
    public static String QUEUE_NAME_3 = "topic-queue-3";

    public static String ROUTING_PATTERN_1 = "asia.china.*";
    public static String ROUTING_PATTERN_2 = "asia.china.#";
    public static String ROUTING_PATTERN_3 = "asia.*.*";

    public static String ROUTING_KEY_1 = "asia.china.nanjing";
    public static String ROUTING_KEY_2 = "asia.china";
    public static String ROUTING_KEY_3 = "asia.china.beijing";

    private final static String MESSAGE_1 = "First Topic Message Example";
    private final static String MESSAGE_2 = "Second Topic Message Example";
    private final static String MESSAGE_3 = "Third Topic Message Example";

    public void createExchangeAndQueue(){
        try{
            Connection conn = RabbitMQConnection.getConnection();
            if(conn != null){
                Channel channel = conn.createChannel();
                channel.exchangeDeclare(EXCHANGE_NAME, ExchangeType.TOPIC.getExchangeName(), true);
                // First Queue
                channel.queueDeclare(QUEUE_NAME_1, true, false, false, null);
                channel.queueBind(QUEUE_NAME_1, EXCHANGE_NAME, ROUTING_PATTERN_1);

                // Second Queue
                channel.queueDeclare(QUEUE_NAME_2, true, false, false, null);
                channel.queueBind(QUEUE_NAME_2, EXCHANGE_NAME, ROUTING_PATTERN_2);

                // Third Queue
                channel.queueDeclare(QUEUE_NAME_3, true, false, false, null);
                channel.queueBind(QUEUE_NAME_3, EXCHANGE_NAME, ROUTING_PATTERN_3);

                channel.close();
                conn.close();
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
    public void publish(){
        try{
            Connection conn = RabbitMQConnection.getConnection();
            if(conn != null){
                Channel channel = conn.createChannel();

                // First message sent by using ROUTING_KEY_1
                channel.basicPublish(TopicExchange.EXCHANGE_NAME, TopicExchange.ROUTING_KEY_1, null, MESSAGE_1.getBytes());
                System.out.println(" Message Sent '" + MESSAGE_1 + "'");

                // Second message sent by using ROUTING_KEY_2
                channel.basicPublish(TopicExchange.EXCHANGE_NAME, TopicExchange.ROUTING_KEY_2, null, MESSAGE_2.getBytes());
                System.out.println(" Message Sent '" + MESSAGE_2 + "'");

                // Third message sent by using ROUTING_KEY_3
                channel.basicPublish(TopicExchange.EXCHANGE_NAME, TopicExchange.ROUTING_KEY_3, null, MESSAGE_3.getBytes());
                System.out.println(" Message Sent '" + MESSAGE_3 + "'");

                channel.close();
                conn.close();
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}


Re
package com.tata.exchange.topic;
import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;
import com.tata.RabbitMQConnection;

import java.io.UnsupportedEncodingException;

public class Receiver {

    public void receive(){
        try{
            Connection conn = RabbitMQConnection.getConnection();
            if(conn != null){
                Channel channel = conn.createChannel();
                // Consumer reading from queue 1
                Consumer consumer1 = new DefaultConsumer(channel) {
                    @Override
                    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws  UnsupportedEncodingException {
                        String message = new String(body, "UTF-8");
                        System.out.println(" Message Received Queue 1 '" + message + "'");
                    }
                };
                channel.basicConsume(TopicExchange.QUEUE_NAME_1, true, consumer1);

                // Consumer reading from queue 2
                Consumer consumer2 = new DefaultConsumer(channel) {
                    @Override
                    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws  UnsupportedEncodingException {
                        String message = new String(body, "UTF-8");
                        System.out.println(" Message Received Queue 2 '" + message + "'");
                    }
                };
                channel.basicConsume(TopicExchange.QUEUE_NAME_2, true, consumer2);

                // Consumer reading from queue 3
                Consumer consumer3 = new DefaultConsumer(channel) {
                    @Override
                    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws UnsupportedEncodingException {
                        String message = new String(body, "UTF-8");
                        System.out.println(" Message Received Queue 3 '" + message + "'");
                    }
                };
                channel.basicConsume(TopicExchange.QUEUE_NAME_3, true, consumer3);

                Thread.sleep(5000);
                channel.close();
                conn.close();
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }

}

package com.tata.exchange.topic;

public class Main {
    public static void main(String[] args) {
        try{
            TopicExchange ex = new TopicExchange();
            ex.createExchangeAndQueue();

            // Publish
            TopicExchange produce = new TopicExchange();
            produce.publish();

            // Consume
            Receiver receive = new Receiver();
            receive.receive();
        }catch(Exception e) {
            e.printStackTrace();
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////

Headers Exchange :- A headers exchange is an exchange which route messages to queues based on message header values instead of routing key. Producer adds some values in a form of key-value pair in message header and sends it to headers exchange. After receiving a message, exchange try to match all or any (based on the value of “x-match”) header value with the binding value of all the queues bound to it. If match is found, it route the message to the queue whose binding value is matched and if match is not found, it ignored the message.

Producer can add one special value in the header of the message called as “x-match“, The “x-match” can have two different values, “any” or “all“, where “all” is the default value. “all” means all the header key-value pairs must match while “any” means at least one of the headers key-value pairs must match with the binding value of the queue. The value in header key-value pairs can be of any data type like integer, string or even hash.



