What and Why is rabbitMQ

Distributed Apps

Messaging and its standards

AMQP 

RabbitMQ
 Server infrastructure.

Programming with RabbitMQ.

-java,javascript,.net,python......

/////////////////////////////////////////////////////////////////////////////////////////////

What is Distributed Computing?

Distributed computing (or distributed processing) is the technique of linking together multiple computer servers over a network into a cluster, to share data and to coordinate processing power. Such a cluster is referred to as a “distributed system.

Application components

1.biz logic -----DataSource
2.user interface

Types of Distributed?


1.Main frame
   -Data access logic / Data sources
   -biz logic 
every thing kept inside one single maiframe

2.thin 
  clients - having small software which connects main frameworks


2.client -server 

  Server will hold data only -data source/database
  Client will hold biz logic
  
3.Tier /layered client- server model

 -single tier
   Server will hold data only -data source/database
   Client will hold biz logic
 -two tier client-server
    server will have biz logic and data
    clients will have only user interfaces

 - three tier client-server arch 
      
     server will have biz logic  +data sources
     client will have biz logic - user interface  +biz logic  

after 1995 : introduction web

 -n tier client server arch

    server is broken into multiple servers
	
	  -webserver
          -app server will  have biz logic
          -database servers will have only datasources
          -middlewares will have brokers like rabbit mq.
          -clients will have ui 

/////////////////////////////////////////////////////////////////////////////////////////////

Distributed App design:

1.Old Distributed App we call monolithic.
2.new distributed app we call microservices.


Monolith:

 One App 
    --Orders
    --Customers
    --Payments
    --Inventory
   etc......

-single language -java/.net/python
-mostly single database -oracle,db2
-deployment - waterfall model -one go deployment
-down time is more
-vendor lock-in.

Program communication:
 Any app / any pl follows some patterns like object programming models

if your app is built on java, objects collabrate each other.

 Client-----Product----->Cart----->Order--Checkout-->Payment----|

Objects can talk each other for "Exchanging Message" : Message Passing.

Micro Services
 Single App is divided into multi domain apps

  -Order App
      -it has its own database
      -it has its own pl
      -its has its own team
     etc.....

  -Customer App

  -Inventory App


Remote Procedure Invocation:
.............................

 if programs are running as different applications, on different runtimes

 Objects on the same runtime - JVM

 Objects on different jvms - Distributed object communication.

Challanges:

 1. Process to Process communication - ipc

 2. Process are two machines - Network is involed

 3. Messages are passed via wire - Message passing protocals.

 4. Message Formats - BOTH Apps need to agree on same format - xml,json,protocalbuff....
  
IF SAME RUN TIME: JAVA

 -RMI - USED for JVM TO JVM

IF Different Runtime :Java to C++ : Enterprise Integration.

ORB - CORBA

Challanges in the RPC Based Middleware:

1. Both parties need to be available at the same point of time.

2. Programs are sync , communicate which leads blocking 

Blocking and Non Blocking:

 1. if a thread is blocked for a long running operation,os cant reuse that thread for 
   other operations.
    which leads more memory useage and it takes more cpu resource.

Non Blocking:

    "Having limitted no threads achive higher concurrency"

  lets say
      100 req =100 thread  = blocking mode

      100 req =  1 thread  =non blocking

      1 thread how can handle 100 request => async programming.

////////////////////////////////////////////////////////////////////////////////////////////

NON Blocking and Async Implementations:

1.Programming language /Framework /lib level
    eg:javascript
  eg:
     NIO,Netty,Vert.x,Spring With Netty/WebFlux


Language level communications are best , it increases speed.

It has its own drawbacks.

1. if caller is sending req,if callee not avaiable.

2. if caller is sending message need to persisted for period of time.

3. if messages are huge , i want to store only, i am  not interested process now.

4. if caller is sending message, he needs ack for message delivery.
/////////////////////////////////////////////////////////////////////////////////////////////
				MOM
                       Message Oriented Middlewares


Message-oriented middleware (MOM) is software or hardware infrastructure supporting sending and receiving messages between distributed systems. MOM allows application modules to be distributed over heterogeneous platforms and reduces the complexity of developing applications that span multiple operating systems and network protocols.

MOM Started in late 1990s for enterprise integration.


### Advantages:
Asynchronicity
Routing
Transformation

MOM implemntations who called  "Message Brokers"

Many Compaines who started building MOM Products

1.TIBCO Enterprise Message Service
2.Amazon SNS
3.IBM MQ
4.Microsoft MQ
5.RabbitMQ

etc...

Problems among MOM products

1.No standards


# Messaging Standards:

Historically, there was a lack of standards governing the use of message-oriented middleware that has caused problems. Most of the major vendors have their own implementations, each with its own application programming interface (API) and management tools.

# Advanced Message Queuing Protocol :Advanced Message Queuing Protocal

AMQP is the Internet Protocol for Business Messaging

The Advanced Message Queuing Protocol (AMQP) is an open standard for passing business messages between applications or organizations.  

It connects systems, feeds business processes with the information they need and reliably transmits onward the instructions that achieve their goals.

History:

AMQP was originated in 2003 by John O'Hara at JPMorgan Chase in London.
AMQP was conceived as a co-operative open effort. 

The initial design was by JPMorgan Chase from mid-2004 to mid-2006 and it contracted iMatix Corporation to develop a C broker and protocol documentation.

In 2005 JPMorgan Chase approached other firms to form a working group that included Cisco Systems, IONA Technologies, iMatix, Red Hat, and Transaction Workflow Innovation Standards Team (TWIST). 

In the same year JPMorgan Chase partnered with Red Hat to create Apache Qpid, initially in Java and soon after C++.

Independently, RabbitMQ was developed in Erlang by Rabbit Technologies, followed later by the Microsoft and StormMQ implementations.

The working group grew to 23 companies including Bank of America, Barclays, Cisco Systems, Credit Suisse, Deutsche Börse, Goldman Sachs, HCL Technologies Ltd, Progress Software, IIT Software, INETCO Systems Limited, Informatica (including 29 West), JPMorgan Chase, Microsoft Corporation, my-Channels, Novell, Red Hat, Software AG, Solace Systems, StormMQ, Tervela Inc., TWIST Process Innovations ltd, VMware (which acquired Rabbit Technologies) and WSO2.


AMQP certified by In August 2011, the AMQP working group announced its reorganization into an OASIS member section.

/////////////////////////////////////////////////////////////////////////////////////////////


Where is AMQP Protocal?

The AMQP  protocol is used by Microsoft Azure Service Bus, Service Bus for Windows Server, Azure Event Hubs, Azure IoT Hub, and by numerous open source projects like Apache Qpid, Apache ActiveMQ, and Apache Apollo, as well as by commercial messaging products of other vendors like JBoss A-MQ, RedHat MRG, SwiftMQ, and IBM MQLight.


## Key Capabilities

AMQP connects across:

Organizations – applications in different organizations
Technologies – applications on different platforms
Time – systems don’t need to be available simultaneously
Space – reliably operate at a distance, or over poor networks


Business Case

The main reasons an enterprise will chose AMQP over proprietary alternatives are:

Realize the savings commoditization brings; remove vendor lock-in
Connect applications on different platforms; choose the right platform for the job
Connect to business partners using a full featured open standard; remove technical barriers to trade 
Position for innovations built upon the foundation of AMQP

Key Features
AMQP was designed with the following main characteristics as goals:

Security
Reliability
Interoperability
Standard
Open

Versions:
0.8
0.9
0.9.1 - RabbitMQ written
0.10
1.0 -Latest
////////////////////////////////////////////////////////////////////////////////////////////

                                       AMQP Spec

Before getting into.

Any Protocal(http,tcp,smtp) , is based on specifications(ideas -how it works) - functional
and tech req.

Protocal is implemented by using programming language. every protocal is program.

http is written in c, http is c program.

AQMP is also spec, can be written in any language - erlang,c



Protocal Architecture:


The AMQP protocol is a binary protocol with modern features: it is multi-channel, negotiated,
asynchronous, secure, portable, neutral, and efficient. AMQP is usefully split into two layers:


+------------------Functional Layer----------------+
| |
| Basic Transactions Exchanges Message queues |
| |
+--------------------------------------------------+
+------------------Transport Layer-----------------+
| |
| Framing Content Data representation |
| |
| Error handling Heart-beating Channels |
| |
+--------------------------------------------------+

The functional layer defines a set of commands (grouped into logical classes of functionality) that do useful work on behalf of the application.

The transport layer that carries these methods from application to server, and back, and which handles channel multiplexing, framing, content encoding, heart-beating, data representation, and error handling.


General Architecture:

AMQ Model Architecture



what a middleware server is /Server?

it is a data server that accepts messages and does two main things with them, 

it routes them to different consumers depending on arbitrary criteria, and it buffers them in memory or on disk when consumers are not able to accept them fast enough


In a pre-AMQP server these tasks are done by monolithic engines that implement specific types of routing and buffering. The AMQ model takes the approach of smaller, modular pieces that can be combined in more diverse and robust ways. It starts by dividing these tasks into two distinct roles:

1. The exchange, which accepts messages from producers and routes them message queues.

2. The message queue, which stores messages and forwards them to consumer applications.

There is a clear interface between exchange and message queue, called a "binding".



AMQP provides runtime-programmable semantics, through two main aspects:

Who can create Exchange and Queues?

 - At Server level by Server admins
 - By The application Programmers


1. The ability at runtime via the protocol to create arbitrary exchange and message queue types.

2. The ability at runtime via the protocol to wire exchanges and message queues together to create any required message-processing system.


The Message Queue:
.................

A message queue stores messages in memory or on disk, and delivers these in sequence to one or more consumer applications.


Message queues are message storage and distribution entities. Each message queue
is entirely independent and is a reasonably clever object..


A message queue has various properties: private or shared, durable or temporary, client-named or servernamed, etc

By selecting the desired properties we can use a message queue to implement conventional middleware entities such as:


A shared store-and-forward queue, which holds messages and distributes these between consumers on a round-robin basis. Store and forward queues are typically durable and shared between multiple consumers.

A private reply queue, which holds messages and forwards these to a single consumer.

Reply queues are typically temporary, server-named, and private to one consumer.

A private subscription queue, which holds messages collected from various "subscribed" sources, and forwards these to a single consumer.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
                                         
					RabbitMQ


What is RabbitMQ?
   RabbitMQ is the most widely deployed open source message broker.
   RabbitMQ is refence implementation of AMQP Protocal.
   RabbitMQ supports other messaging protocals
     -STOMP -The Simple Text Oriented Messaging Protocol
     -MQTT  - IOT messaging protocal.
   RabbitMQ is written Erlang


Erlang:
   As a highly performant, stable, and clusterable message broker, it’s no surprise that
RabbitMQ has found a home in such mission-critical environments as the centerpiece
of large-scale messaging architectures.

It was written in Erlang, the telco-grade, functional programming language designed at the Ericsson Computer Science Laboratory in the mid-to-late 1980s.

 Erlang was designed to be a distributed, fault-tolerant, soft real-time system for applications that require 99.999% uptime.

 As a language and runtime system, Erlang focuses on lightweight processes that pass messages between each other, providing a high level of concurrency with no shared state.


Erlang’s design, which focused on concurrent processing and message passing, made
it a natural choice for a message broker like RabbitMQ:

As an application, a message broker maintains concurrent connections, routes messages, and manages their states.

In addition, Erlang’s distributed communication architecture makes it a natural for
RabbitMQ’s clustering mechanism. 

Servers in a RabbitMQ cluster make use of Erlang’s
inter-process communication (IPC) system, offloading the functionality that many competing
message brokers have to implement to add clustering capabilities.


RabbitMQ Low Level Architecture:
................................

 RabbitMQApp
    |
 Erlang VM


RabbitMQ Application Architecture:

Virtual Host or Vhost is logical representation of RabbitMQ services like Apache virtuals Hosts

"The term Virtual Host refers to the practice of running more than one web site (such as company1.example.com and company2.example.com) on a single machine"

RabbiMQ can run isloated services..

Each Vhost is collections of  Entities/Components

 1.Connections
 2.Exchanges
 3.Queues
 4.Bindings
 5.Security Settings - Users and its permissions


In Enterprise, We can have more than one machines/servers and each server can have more than one vhosts.

Resources can be shared across vhosts like queue sharings.
/////////////////////////////////////////////////////////////////////////////////////////////

RabbitMQ : Installation


There are two versions of RabbitMQ

1.Open source

2.Enterprise - CloudAMQP -https://www.cloudamqp.com/


RabbitMQ is highly portable , we can install any where.

Linux,BSD,UNIX : Debian,Ubuntu,RHEL,CentOS,Fedora,Solaris.
Windows : Chocolatey or installer ,binary

MACOS : Homebrew 

Elang/OTP for RabbitMQ

Docker

RabbitMQ ON kubernetes Cluster

Cloud :
  CloudAMQ
  AWS EC2
/////////////////////////////////////////////////////////////////////////////////////////////

Linux :

setup file

#!/bin/sh

## If sudo is not available on the system,
## uncomment the line below to install it
# apt-get install -y sudo

sudo apt-get update -y

## Install prerequisites
sudo apt-get install curl gnupg -y

## Install RabbitMQ signing key
curl -fsSL https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc | sudo apt-key add -

## Install apt HTTPS transport
sudo apt-get install apt-transport-https

## Add Bintray repositories that provision latest RabbitMQ and Erlang 23.x releases
sudo tee /etc/apt/sources.list.d/bintray.rabbitmq.list <<EOF
## Installs the latest Erlang 23.x release.
## Change component to "erlang-22.x" to install the latest 22.x version.
## "bionic" as distribution name should work for any later Ubuntu or Debian release.
## See the release to distribution mapping table in RabbitMQ doc guides to learn more.
deb https://dl.bintray.com/rabbitmq-erlang/debian bionic erlang
## Installs latest RabbitMQ release
deb https://dl.bintray.com/rabbitmq/debian bionic main
EOF

## Update package indices
sudo apt-get update -y

## Install rabbitmq-server and its dependencies
sudo apt-get install rabbitmq-server -y --fix-missing

/////////////////////////////////////////////////////////////////////////////////////////////

Afer installing , How to verify the rabbitmq server is running? How to start,stop,restart Rabbit MQ Server.


Two ways:

1.Using linux system command called "service"

2.Rabbit MQ server offers lot of tools.


Linux:

 $sudo service rabbitmq-server stop 
 $sudo service rabbitmq-server status
 $sudo service rabbitmq-server start
 $sudo service rabbitmq-server restart

2.RabbitMQ offers lot of tools

2.1.cli tools

1.rabbitmqctl for service management and general operator tasks

2.rabbitmq-diagnostics for diagnostics and health checking

3.rabbitmq-plugins for plugin management

4.rabbitmq-queues for maintenance tasks on queues, in particular quorum queues

5.rabbitmq-upgrade for maintenance tasks related to upgrades

2.2. Management UI Tool
     GUI Web Interface through which you can monitor

2.3. HTTP Api
       offers REST API, which returns server information, you can get and also pass to other applications
///////////////////////////////////////////////////////////////////////////////////////////

rabbitqctl :
  Tool for mananging Rabbit MQ nodes

Syntax:
   rabbitmqctl -options

rabbitmqctl [--node <node>] [--timeout <timeout>] [--longnames] [--quiet] <command> [<command options>]

rabbitmqctl [-n <node>] [-t <timeout>] [-l] [--quiet] <command> [<command options>]

Every RabbitMQ Server starts with default Node Name..

Name : rabbit@target-hostName

How to start RabbitMQ server?

1.Via System service command

2.Via rabbitmq binary command
   sudo rabbitmq-server 

Mode of Server Startup :

1. log mode

 sudo rabbitmq-server

  ##  ##      RabbitMQ 3.8.2
  ##  ##
  ##########  Copyright (c) 2007-2019 Pivotal Software, Inc.
  ######  ##
  ##########  Licensed under the MPL 1.1. Website: https://rabbitmq.com

  Doc guides: https://rabbitmq.com/documentation.html
  Support:    https://rabbitmq.com/contact.html
  Tutorials:  https://rabbitmq.com/getstarted.html
  Monitoring: https://rabbitmq.com/monitoring.html

  Logs: /var/log/rabbitmq/rabbit@ip-172-31-3-18.log
        /var/log/rabbitmq/rabbit@ip-172-31-3-18_upgrade.log

  Config file(s): (none)

  Starting broker... completed with 0 plugins.

After starting : You can check status

$sudo rabbitmqctl status


2. Detached Mode
  $ sudo rabbitmq-server -detached
Warning: PID file not written; -detached was passed.

After starting : You can check status

$sudo rabbitmqctl status

Shudown the server and check the status.

$sudo rabbitmqctl shutdown

$sudo rabbitmqctl status
/////////////////////////////////////////////////////////////////////////////////////////////
How to view Management Information?

//////////////////////////////////////////////////////////////////////////////////////////

How to install Rabbit In Windows?

windows binary

or 

choco install rabbitmq
.............................................................................................

rabbit MQ Boot Process:
.......................

$sudo rabbitmq-server start
          |
          loaded into main memory
               |
              Process(Erlang) is ready


 Since Rabbit Mq is server , which has default port 5672.

Rabbit MQ server mostly powered with configurations.


$sudo rabbitmq-server start
          |
          loaded into main memory
               |
              Process(Erlang) is ready
                |
                starts reading a configuration file
                        /etc/rabbitmq

Lab : 
1.Testing config files
  $ls -l /etc/rabbitmq

 by default there will be no files , empty


$sudo rabbitmq-server start
          |
          loaded into main memory
               |
              Process(Erlang) is ready
                |
                starts reading a configuration file
                        /etc/rabbitmq

Under this folder you can have three major configuration files, which need to be created
manually.

1.rabbitmq-env.conf

$sudo rabbitmq-server start
          |
          loaded into main memory
               |
              Process(Erlang) is ready
                |
                starts reading a configuration file
                        /etc/rabbitmq/rabbitmq-env.conf --entry file where major 
RabbitMQ configurations are found.

 But we have seen no such file , found. then how rabbit mq works.

    ->RabbitMQ has distributed default settings along with rabbitmq server.




$cat /etc/rabbitmq/rabbitmq-env.conf
# Defaults to rabbit. This can be useful if you want to run more than one node
# per machine - RABBITMQ_NODENAME should be unique per erlang-node-and-machine
# combination. See the clustering on a single machine guide for details:
# http://www.rabbitmq.com/clustering.html#single-machine
#NODENAME=rabbit

# By default RabbitMQ will bind to all interfaces, on IPv4 and IPv6 if
# available. Set this if you only want to bind to one network interface or#
# address family.
#NODE_IP_ADDRESS=127.0.0.1

# Defaults to 5672.
#NODE_PORT=5672


The default Settings for RabbitMQ:

1.Node
   Node is logical representation machine,on which rabbitmq application are running
2.Port
   Node is running on default port is 5672
3.Default log file
   /var/log/rabbitmq

Lab verify log files

$ls -l /var/log/rabbitmq
/////////////////////////////////////////////////////////////////////////////////////////////

How to run multiple rabbitmq server or  How to change rabbitmq server node name,port no from defalult settings?

Condition :

1.Each server should run in different port
2.Each server must have unique name.


Solution :  

You have to supply node name and port no differntly when you start server.

RabbitMQ can be configured by using three configurations

1.The first way is to use the RabbitMQ environment variables that lie on the environment variables of the operating system.

2.the second way is through the configuration file provided by RabbitMQ.
   rabbitmq.conf

3.the last way is to use runtime parameters
   A special runtime parameters are supplied to rabbitmq server when server runngi


Environment Variables:

 Environment variables are supplied by RabbitMQ-Built in.

Environment variables are configured 
         1.inside rabbitmq-env.conf file : static configuration
         2.during server startup via commandline.


common environment variables
*****************************

RABBITMQ_NODE_IP_ADDRESS:
	Change this if you only want to bind to one network interface. Binding to two or more interfaces can be set up in the configuration file.
	Default: an empty string, meaning "bind to all network interfaces".

RABBITMQ_NODE_PORT	
	Default: 5672.

RABBITMQ_NODENAME
	The node name should be unique per Erlang-node-and-machine combination. To run multiple nodes, see the clustering guide.
	Default:
	Unix*: rabbit@$HOSTNAME
	Windows: rabbit@%COMPUTERNAME%

RABBITMQ_CONFIG_FILE
	Main RabbitMQ config file path.

RABBITMQ_ADVANCED_CONFIG_FILE
	"Advanced" (Erlang term-based) RabbitMQ config file 

RABBITMQ_CONF_ENV_FILE
	Location of the file that contains environment variable definitions (without the RABBITMQ_ prefix).
   default
	Ubuntu and Debian: /etc/rabbitmq/rabbitmq-env.conf

RABBITMQ_MNESIA_BASE
	This base directory contains sub-directories for the RabbitMQ server's node database, message store and cluster state files, one for each node, unless RABBITMQ_MNESIA_DIR is set explicitly.

  default:
	Ubuntu and Debian packages: /var/lib/rabbitmq/mnesia/

RABBITMQ_MNESIA_DIR
	The directory where this RabbitMQ node's data is stored. This s a schema database, message stores, cluster member information and other persistent node state.

RABBITMQ_PLUGINS_DIR
	The list of directories where plugin archive files are located and extracted from. This is PATH-like variable, where different paths are separated by an OS-specific separator (: for Unix, ; for Windows). Plugins can be installed to any of the directories listed here. Must not contain any characters mentioned in the path restriction section.

	Ubuntu and Debian packages: /var/lib/rabbitmq/plugins

///////////////////////////////////////////////////////////////////////////////////////////

Lab:

 Server more rabbit mq servers

By default rabbit mq server starts in default 

$sudo rabbitmq-server 

  Default node

How to a new another server on the same host(server)

$sudo RABBITMQ_NODE_PORT=5673 RABBIT_NODENAME=tatanode rabbitmq-server -detached

How to connect rabbit mq server instance?

-rabbitmqctl tool
-app develoer
-management

rabbitmqctl [--node <node>] [--timeout <timeout>] [--longnames] [--quiet] <command> [<command options>]

Steps:
1. sudo RABBITMQ_NODE_PORT=5675 RABBITMQ_NODENAME=tatanode rabbitmq-server

sudo rabbitmqctl --node tatanode status

//////////////////////////////////////////////////////////////////////////////////////////////

Management UI:
.............

Env:

 - if you are in windows, after installing, you can access managment 
  localhost:15672
 - default user at local host is guest, guest

- if you are in linux, vm or bare , cloud

Plugins:
  Collection of utitiles , which are programs must be installed to view management dashboard
which is simple web application.

Plugins extend the rabbit mq server core functionality.

Features:
 -supports additional amqp protocal exchange types
 -monitoring tools
 -federation types

How to enable ,disable , install plugins

Syntax:

rabbitmq-plugins enable <plugin-name>

  
eg:
rabbitmq-plugins enable rabbitmq_peer_discovery_k8s


Disabling:

rabbitmq-plugins disable <plugin-name>
rabbitmq-plugins disable rabbitmq_top

$sudo rabbitmq-plugins directories -s

Plugin archives directory: /usr/lib/rabbitmq/plugins:/usr/lib/rabbitmq/lib/rabbitmq_server-3.8.14/plugins
Plugin expansion directory: /var/lib/rabbitmq/mnesia/rabbit@ip-172-31-4-201-plugins-expand
Enabled plugins file: /etc/rabbitmq/enabled_plugins

////////////////////////////////////////////////////////////////////////////////////////////

Use case: How to access management dashboard.

if you are in local host , you can access management console easily.

Note : 
 1.windows , no need of installing management_plugin , which installed by default

 2.Linux , we need to install management_plugin.
    sudo rabbitmq-plugins enable rabbitmq_management

How to access?

aws ec2 instance
  http://13.233.158.60:15672/

if it is local
  http:localhost//15672

Login creditionals:

if it is localhost domain.
 you can login using guest guest 

if it is remote login - like cloud aws/gcp..

you cant use guest user 


I need to create use admin user.

Authentication, Authorisation, Access Control
..............................................

How to create new user and offers  admin rights.

steps:

1. create user and password
syntax:
 sudo rabbitmqctl add_user userName password
 sudo rabbitmqctl add_user  root root

2. set user category-administrator
 syntax:
 sudo rabbitmqctl set_user_tags userName category
 
$ sudo rabbitmqctl set_user_tags admin administrator

To list created users;

~$ sudo rabbitmqctl list_users
Listing users ...
user    tags
admin   [administrator]
guest   [administrator]
root    [administrator]


If you delete users:
$rabbitmqctl delete_user 'username'
$rabbitmqctl delete_user 'admin'


Setting Permissions to access virtual Host:

To grant permissions to a user in a virtual host, use rabbitmqctl set_permissions:

sudo rabbitmqctl set_permissions -p "/" "root" ".*" ".*" ".*"


Full steps to create users

1.sudo rabbitmqctl add_user root root 
2.sudo rabbitmqctl set_user_tags admin administrator
3.sudo rabbitmqctl set_permissions -p "/" "root" ".*" ".*" ".*"

///////////////////////////////////////////////////////////////////////////////

User Tags:

Comma-separated list of tags to apply to the user. Currently supported by the management plugin:

-management
	User can access the management plugin.

-policymaker
	User can access the management plugin and manage policies and parameters for the vhosts they have access to.

monitoring
	User can access the management plugin and see all connections and channels as well as node-related information.

administrator
		User can do everything monitoring can do, manage users, vhosts and permissions, close other user's connections, and manage policies and parameters for all vhosts.
///////////////////////////////////////////////////////////////////////////////////////////

Virtual Hosts:
.............

Virtual Host is management web application.
Which consits of Connections,Exchanges,Queues,Users and permissions.

Virtual Hosts are similar to another virtual hosts present in web containers like apache, nginx.

How to virtual hosts in RabbitMQ can be created and deleted using 

->rabbitmqctl cli tool
->via HTTP rest apis

Logical and Physical Separation:
.................................

-Vhosts never separte RabbitMQ server physically.
 means that many vhosts can run on single erlang process(server) process.

Client Connections And Vhosts:
...............................
A virtual host has a name. When an AMQP 0-9-1 client connects to RabbitMQ, it specifies a vhost name to connect to. 

If authentication succeeds and the username provided was granted permissions to the vhost, connection is established

////////////////////////////////////////////////////////////////////////////////////////////

How to create Vhosts?

-via http api
-via rabbitmqctl tool
-via management dashboard tool.



CLI:

Adding new Vhost

$ sudo rabbitmqctl add_vhost product
Adding vhost "product" ...

Delete existing Vhost

$sudo rabbitmqctl delete_vhost product
Deleting vhost "product" ...
ubuntu@ip-172-31-4-201:~$

How to limit max client connections and max queues?

Client connections at  a time:

$rabbitmqctl set_vhost_limits -p vhost_name '{"max-connections": 256}'

How many queues we can create

$rabbitmqctl set_vhost_limits -p vhost_name '{"max-queues": 1024}'

////////////////////////////////////////////////////////////////////////////////////////////
                                     RabbitMQ Programming
............................................................................................

RabbitMQ is just middleware, can be connected with any programming language.

Java,C#,Python,Ruby,Node.js(javascript),Go,Swift....


Program Types:

1.Producer 
2.Consumer

Components:

1.Exchange

2.Queue

How clients are conntected with RabbitMQ Server?

As Per AQMP Protocal specification.

Clients(Producer && Consumer) talks to RabbitMQ Server via "TCP" Protocal.

Clients establish TCP connection with RabbitMQ Server.

Work Flow:

1.Client tries to connect server by sending TCP header
2.Server returns All Protocal messages
3.Client sends authentication info like username and password
4.Server responds auth success/failure
5.If success, Then select vhost
6.Once VHost ready, then it is ready to send or receive messages

According to this spec, Client Libs must Provide , Connection Implementation.


Channel:
 -It is Virtual Connection between your application and TCP



 jdbc:oracle:thin:Tcp/Ip:@localhost:1521:xe","system","oracle"
  |     |      |
protocal        subprotocal
       subprotocal

jdbc is universal protocal developed by sun micro system to talk to any datasources.

oracle -orcl
..............................................................................................

Programming : Java : amqp client.

Steps:

1.Create Maven Project
pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>RabbitMQJavaClientApp</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>
    <dependencies>
        <dependency>
            <groupId>com.rabbitmq</groupId>
            <artifactId>amqp-client</artifactId>
            <version>5.7.1</version>
        </dependency>
    </dependencies>
</project>
/////////////////////////////////////////////////////////////////////////////////////////

Step 2:

Establish Connection with RabbitMQ Server.

-ConnectionFactory:

com.rabbitmq.client.ConnectionFactory 
   -Convenience "factory" class to facilitate opening a Connection to an AMQP broker.

 ConnectionFactory factory = new ConnectionFactory();
 factory.setHost(hostName);
 factory.setPort(portNumber);
 factory.setVirtualHost(virtualHost);
 factory.setUsername(username);
 factory.setPassword(password);
 Connection conn = factory.newConnection();


ConnectionTest.java

package com.tata.amqp.basic;

import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class ConnectionTest {
    public static void main(String[] args) {
       ConnectionFactory connectionFactory = new ConnectionFactory();
       //set connection parameters
        connectionFactory.setHost("localhost");
        connectionFactory.setPort(5672);
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        connectionFactory.setVirtualHost("/");
        //connection
        try {
            Connection connection = connectionFactory.newConnection();
            System.out.println("Connection Established");
        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////

Send Message,Consume The Message:


Publisher ---------->Exchange------->Queue------>Consumer

Note: 
The publisher need to use explicit exchange, we dont need to create any exchange, we can
send message. 
RabbitMQ uses a default Exchange to send Message to the Queue.


In order to publish message:

-Exchange may be there - inside rabbitmq server -named Exchange.
-Queue must be there
    Queue can be created via client program - PUblisher
    Queue can be created inside RabbitMQ Server and use it.


How to create a Queue from java?

Using channel Object

channel.queueDeclare​(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map<String,​Object> arguments)


package com.tata.amqp.basic;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;

import java.io.IOException;

public class Producer {
    private static final String QUEUE_NAME = "hello";

    public static void main(String[] args) {

        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {

            Channel channel = connection.createChannel();
            //create queue
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            System.out.println(QUEUE_NAME + "Created ");


        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}




How to publish a message into created Queue?

basicPublish​(String exchange, String routingKey, boolean mandatory, boolean immediate, AMQP.BasicProperties props, byte[] body)


package com.tata.amqp.basic;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;

import java.io.IOException;

public class Producer {
    private static final String QUEUE_NAME = "hello";

    public static void main(String[] args) {

        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {

            Channel channel = connection.createChannel();
            //create queue
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            System.out.println(QUEUE_NAME + "Created ");

            //Publish Message
            String message = "Hello RabbitMQ";
            channel.basicPublish("",QUEUE_NAME,null,message.getBytes());
            System.out.println(" Sent " + message + " ");


        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

Consuming:

 Consumers are listeners, who listens for messages from the RabbitMQ.
 Consumer has to run like demon process.

 Messages May be published any time into Queue.

Context:

  1.Consumer may run as long process to wait for incoming messages
  2.Consumer when every start , who can read messages.

The message Processing is "Async" : Event Driven Programming.

How to implment async pattern to read messages in java?

 "Callback" Pattern.

RabbitMQ offers

com.rabbitmq.client

Interface DeliverCallback

Functional Interface:

This is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference.


package com.tata.amqp.basic;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;
import com.rabbitmq.client.Delivery;

import java.io.IOException;

public class Consumer {
    private static final String QUEUE_NAME = "hello";

    public static void main(String[] args) {
        //Same COnnection Information
        Connection connection = RabbitMQConnectionUtil.getConnection();
        //Channel
        try {
            Channel channel = connection.createChannel();
            //Get The Queue From where you want to Consume
            //IF the Queue does not exit it will create, other wise it will try to use existing queue
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            System.out.println("App is Waiting for Messages.. To exit press CTRL + C");
            //Lambda /Callback Function to read message:
            DeliverCallback callback = (String consumerTag, Delivery delivery) -> {
                //read message
                System.out.println("Message is Available");
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message : " + message);
            };
            //Consume : Syntax - 1 : declaring callback function separely and consume it
//            channel.basicConsume(QUEUE_NAME, true, callback, consumerTag -> {
//            });


            channel.basicConsume(QUEUE_NAME, true, (consumerTag, delivery) -> {
                //read message
                System.out.println("Message is Available");
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message : " + message);
            }, consumerTag -> {
            });

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

How to test , sending interactive messages to Consumers?

start two cmd ; publisher and another for consumer

java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.Producer "hey"

java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.Consumer
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
App is Waiting for Messages.. To exit press CTRL + C
Message is Available
Got Message : hey
.............................................................................................			 How to process Complex Messages with help of multiple Consumers


The previous use was how to send message from single Producer to Single Consumer.

Single Producer, Where mutiple Consumers.

  if one consumer is busy, then we cant send message to the same consumer again.We need to send a message to another consumer.


The way delivery message from producer to multiple consumers one by one called as "Task Queue"

What is Task Queue/Worker Queue?

 if consumer is doing resource insentive task such as image compression,video processing,pdf
creations,preparing large json reports etc.... after getting message(what to do-Task)

Producer has sent a message called "imageCompression" to RabbitMQ server , Where Consumer reads that message and accordingly starts task.. 

RabbitMQ server can push message to the COnsumer after completing long process, which makes queue will be full.

in order to avoid queue full , we can tell rabbit to distribute messages to multiple consumers.
  -Message can be distributed to many consumers 

How message to distribute 
   using Round Robin Dispatching algorthim.

How it works?
 if one message is delivered to one consumer,
 The next message will not be delivered to The consumer, rather which will be delivered to the consumer only

     m1--------------c1
     m2---------------c2
     
Round Robin:
...........

By default,RabbitMQ will send each message to  the single consumer, where consumer is too busy 
for accepting new message.


RabbitMQ can distribute messages to many consumers in round robin fashion.

How to implement Round Robin ?

 By default RabbitMQ server does not know to how to distribute messages to the consumers parallely.

channel.basicQos(prefetchCount) 

channel.basicQos(1)
   This tell rabbitmq not to give more than one message to a worker at a time.

How rabbitMQ server again can send messages to the worker (consumer) again?
  
   The worker Process replies with "ack"
 

Ack:
public abstract String basicConsume(String queue,
                                    boolean autoAck,
                                    com.rabbitmq.client.DeliverCallback deliverCallback,
                                    com.rabbitmq.client.CancelCallback cancelCallback)
queue – the name of the queue
autoAck – true if the server should consider messages acknowledged once delivered; false if the server should expect explicit acknowledgements
deliverCallback – callback when a message is delivered
cancelCallback – callback when the consumer is cancelled


Full Worker:

package com.tata.amqp.basic;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;


public class Worker {

    private static final String TASK_QUEUE_NAME = "task_queue";


    public static void main(String[] argv) throws Exception {
        final Connection connection = RabbitMQConnectionUtil.getConnection();
        //channel
        final Channel channel = connection.createChannel();

        channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);

        System.out.println(" [*] Waiting for messages. To exit press CTRL+C");
        //Implement Round Robin here
        channel.basicQos(1);

        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody(), "UTF-8");

            System.out.println(" [x] Received '" + message + "'");
            try {
                doWork(message);
            } finally {
                System.out.println(" [x] Done");
                //here send ack to rabbitmq server , so that rabbitmq server will re send fresh messages
                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
            }
        };
        channel.basicConsume(TASK_QUEUE_NAME, false, deliverCallback, consumerTag -> { });
    }

    private static void doWork(String task) {
        for (char ch : task.toCharArray()) {
            if (ch == '.') {
                try {
                    //fake delay in process.
                    Thread.sleep(1000);
                } catch (InterruptedException _ignored) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////

Producer Best Practices:

-Producer connection,channel must be closed , so that messages will be reached to RabbitMq
-More connection which leaks memory.


How to close Connection and Channel?

At of the code

 try{
   Connection
   Channel
 }
 catch(){

 }
 finally {
   channel.close()
   connection.close()
 }

Way -2

try-with-resources — introduced in Java 7 — allows us to declare resources to be used in a try block with the assurance that the resources will be closed after the execution of that block.

try (PrintWriter writer = new PrintWriter(new File("test.txt"))) {
    writer.println("Hello World");
}


package com.tata.amqp.basic;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.MessageProperties;

public class NewTask {

    private static final String TASK_QUEUE_NAME = "task_queue";

    public static void main(String[] argv) throws Exception {

        try (Connection connection = RabbitMQConnectionUtil.getConnection();
             Channel channel = connection.createChannel()) {
            channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);

            String message = String.join(" ", argv);

            channel.basicPublish("", TASK_QUEUE_NAME,
                    MessageProperties.PERSISTENT_TEXT_PLAIN,
                    message.getBytes("UTF-8"));
            System.out.println(" [x] Sent '" + message + "'");
        }
    }

}

///////////////////////////////////////////

How to Test?

Open three cmd 

two for consumers and one for producer



//Producer

C:\>java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.NewTask  First Message.
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
 [x] Sent 'First Message.'

C:\>java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.NewTask  Second Message..
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
 [x] Sent 'Second Message..'

C:\>java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.NewTask  Third Message...
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
 [x] Sent 'Third Message...'

C:\>java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.NewTask  Fourth Message....
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
 [x] Sent 'Fourth Message....'




Consumer:

C:\>java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.Worker
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
 [*] Waiting for messages. To exit press CTRL+C
 [x] Received 'First Message.'
 [x] Done
 [x] Received 'Third Message...'
 [x] Done


C:\>java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.Worker
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
 [*] Waiting for messages. To exit press CTRL+C
 [x] Received 'Second Message..'
 [x] Done
 [x] Received 'Fourth Message....'
 [x] Done

//////////////////////////////////////////////////////////////////////////////////////////////
              				Exchanges
//////////////////////////////////////////////////////////////////////////////////////////////

-What is Exchange
-How to bind(connect) Exchange and Queue
     -Bindings : connector for exchange Queue
     -Routing Rules to select A particular queue
-How to connect/bind Producer and Exchange
     -RoutingKeys
-Types of Exchanges


What is Exchange?

 Exchange is a bridge between Producer Application and Queue.

 Exchange takes a message from the Producer application and routes it into 0...more queues.

Types OF exchanges

-Direct 
-Fanout
-Topic
-Headers

Any of type exchange can forward message to Queues

RabbitMQ Provides built in exchanges:

""          -AMQP Default Exchange   --- Direct
amq.direct  ---Direct
amq.fanout  --Fanout
amq.headers  -headers
amq.match    -headers
amq.topic   - topic 

Direct Exchange:

-A Direct Exchange is an exchange which routes messages to queues based on message routing key.

Keys:
-RoutingKey
-BindingKey

RoutingKey:

-The routingKey is a message attribute.

Message Attribute:
  Meta information sent to Exchange along with message(payload)

eg:
  if you send a message from browser/MobileApp/anyHttpClient App to webserver via http protocal.
  message sent  with many message properties(headers in http)
eg:
   accept:application/xml
   Authorization:admin

-The routingKey is added by the producer when message is sent 

.....................................................................................

How Exchange delivers Message to a Queue?

Generally a relationship is established by Exchange with Queues(1...many)

BindingKey:

 -Key used by Exchange to Route Messages to apporapriate Queues.

After receiving a message, exchange try to match the routing key with binding key of all the queues bound to it.
it routes messages the queue whose binding key is matched and if the match is not found, it ignored the message.
///////////////////////////////////////////////////////////////////////////////////////////

Direct Exchange Code:

1.Common code

package com.tata.amqp.basic;

public enum ExchangeType {

    DIRECT("direct"),
    TOPIC("topic"),
    FANOUT("fanout"),
    HEADER("headers");

    private final String exchangeName;

    ExchangeType(String exchangeName) {
        this.exchangeName = exchangeName;
    }

    public String getExchangeName() {
        return this.exchangeName;
    }

}

2.Connection Code

package com.tata.amqp.basic;


import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class RabbitMQConnectionUtil {
    public static Connection getConnection() {
        ConnectionFactory connectionFactory = new ConnectionFactory();
        //set connection parameters
        connectionFactory.setHost("localhost");
        connectionFactory.setPort(5672);
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        connectionFactory.setVirtualHost("/");
        //connection
        Connection connection = null;
        try {
            connection = connectionFactory.newConnection();
           // System.out.println("Connection Established");
        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
        return connection;
    }
}


Exchange and Queue Creation:

package com.tata.amqp.exchange.direct;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.ExchangeType;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

public class DirectExchange {
    //EXCHNAGE Name
    public static String EXCHANGE_NAME = "direct-exchange";
    //Queues
    public static String QUEUE_NAME_1 = "direct-queue-1";
    public static String QUEUE_NAME_2 = "direct-queue-2";
    public static String QUEUE_NAME_3 = "direct-queue-3";

    //Routing Keys
    public static String ROUTING_KEY_1 = "direct-key-1";
    public static String ROUTING_KEY_2 = "direct-key-2";
    public static String ROUTING_KEY_3 = "direct-key-3";

    public void createExchangeQueue() {
        try {
            Connection connection = RabbitMQConnectionUtil.getConnection();
            Channel channel = connection.createChannel();
            //Create Exchange
            channel.exchangeDeclare(EXCHANGE_NAME, ExchangeType.DIRECT.getExchangeName(), true);

            //Queue Creations
            //First Queue
            channel.queueDeclare(QUEUE_NAME_1,true,false,false,null);
            //Bind Queue and Exchange
            channel.queueBind(QUEUE_NAME_1,EXCHANGE_NAME,ROUTING_KEY_1);

            //Second Qeueue
            channel.queueDeclare(QUEUE_NAME_2,true,false,false,null);
            channel.queueBind(QUEUE_NAME_2,EXCHANGE_NAME,ROUTING_KEY_2);

            //Third Qeueue
            channel.queueDeclare(QUEUE_NAME_3,true,false,false,null);
            channel.queueBind(QUEUE_NAME_3,EXCHANGE_NAME,ROUTING_KEY_3);

            channel.close();
            connection.close();

        } catch (Exception e) {
            e.printStackTrace();
        } finally {

        }
    }


}

Publishing Message to Exchange

package com.tata.amqp.exchange.direct;


import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class Producer {
    private final static String MESSAGE_1 = "First Direct Message";
    private final static String MESSAGE_2 = "Second Direct Message";
    private final static String MESSAGE_3 = "Third Direct Message";

    public void publish() {
        try {
            Connection connection = RabbitMQConnectionUtil.getConnection();
            Channel channel = connection.createChannel();
            //Publish message into Exchange with right Routing Key.
            channel.basicPublish(DirectExchange.EXCHANGE_NAME, DirectExchange.ROUTING_KEY_1, null, MESSAGE_1.getBytes());
            System.out.println("Message Published " + MESSAGE_1);

            channel.basicPublish(DirectExchange.EXCHANGE_NAME, DirectExchange.ROUTING_KEY_2, null, MESSAGE_2.getBytes());
            System.out.println("Message Published " + MESSAGE_2);

            channel.basicPublish(DirectExchange.EXCHANGE_NAME, DirectExchange.ROUTING_KEY_3, null, MESSAGE_3.getBytes());
            System.out.println("Message Published " + MESSAGE_3);

            channel.basicPublish(DirectExchange.EXCHANGE_NAME, DirectExchange.ROUTING_KEY_3, null, "Message New".getBytes());
            System.out.println("Message Published " + "Message New");

            channel.close();
            connection.close();

        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }

}

///
Consumer Code:
package com.tata.amqp.exchange.direct;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;
import com.rabbitmq.client.Delivery;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class Consumer {
    public void receive() {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            //Callback for reading from Queue -1
            DeliverCallback consumer1 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From Queue - 1 : " + message);
            };
            channel.basicConsume(DirectExchange.QUEUE_NAME_1,true,consumer1,consumerTag -> {});

            //Callback for reading from Queue -2
            DeliverCallback consumer2 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From Queue - 2 : " + message);
            };
            channel.basicConsume(DirectExchange.QUEUE_NAME_2,true,consumer2,consumerTag -> {});

            //Callback for reading from Queue -3
            DeliverCallback consumer3 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From Queue - 3 : " + message);
            };
            channel.basicConsume(DirectExchange.QUEUE_NAME_3,true,consumer3,consumerTag -> {});


        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

Main App:

package com.tata.amqp.exchange.direct;

public class MainDirectApp {
    public static void main(String[] args) throws InterruptedException {
        //Create Exchange,Queues,Bindings will be ready
        DirectExchange directExchange = new DirectExchange();
        //Publish
        Producer producer = new Producer();
        producer.publish();

        //Consumer to read
        Consumer consumer = new Consumer();
        consumer.receive();

        Thread.sleep(1000);


    }
}
..............................................................................................					  Fanout Exchange
			     (Publisher and Subscriber)
                   Sending messages to many Subscribers/consumers at once
..............................................................................................

-A Fanout exchange is an exchange which routes messages the received message to all the queues
bound it.

-When the producer sends the message to fanout exchange, it copies the message and routes to all the queues that are bound to it.

-It just ignores the routing key or any pattern matching provided by the producer.

-It is really very usefull if you want to store messages in one or more queues.


Code:

1.Common Code : Please Refer the above Program

2.Exchange and Queue Creation.

package com.tata.amqp.exchange.fanout;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.ExchangeType;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;

public class FanoutExchange {
    //EXCHNAGE Name
    public static String EXCHANGE_NAME = "fanout-exchange";
    //Queues
    public static String QUEUE_NAME_1 = "fanout-queue-1";
    public static String QUEUE_NAME_2 = "fanout-queue-2";
    public static String QUEUE_NAME_3 = "fanout-queue-3";

    public static String ROUTING_KEY = "";

    public void createExchangeAndQueue() {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            //Create Exchange
            channel.exchangeDeclare(EXCHANGE_NAME, ExchangeType.FANOUT.getExchangeName(), true);

            //First Queue
            channel.queueDeclare(QUEUE_NAME_1, true, false, false, null);
            //Binding
            channel.queueBind(QUEUE_NAME_1, EXCHANGE_NAME, ROUTING_KEY);
            //Second Queue
            channel.queueDeclare(QUEUE_NAME_2, true, false, false, null);
            //binding
            channel.queueBind(QUEUE_NAME_2, EXCHANGE_NAME, ROUTING_KEY);

            //Third Queue
            channel.queueDeclare(QUEUE_NAME_3, true, false, false, null);
            // binding
            channel.queueBind(QUEUE_NAME_3, EXCHANGE_NAME, ROUTING_KEY);


        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


2.Producer

package com.tata.amqp.exchange.fanout;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class Producer {
    private static final String MESSAGE = "Happy News, Our Company got Ranked 1st  Position";

    public void publish() {
        try {
            Connection connection = RabbitMQConnectionUtil.getConnection();
            Channel channel = connection.createChannel();
            channel.basicPublish(FanoutExchange.EXCHANGE_NAME, FanoutExchange.ROUTING_KEY, null, MESSAGE.getBytes());
            System.out.println("Message Published " + MESSAGE);
            channel.close();
            connection.close();

        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }
}

3.Consumer
package com.tata.amqp.exchange.fanout;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;
import com.rabbitmq.client.Delivery;
import com.tata.amqp.basic.RabbitMQConnectionUtil;
import com.tata.amqp.exchange.direct.DirectExchange;

import java.io.IOException;

public class Consumer {
    public void receive() {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            //Callback for reading from Queue -1
            DeliverCallback consumer1 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From" + FanoutExchange.QUEUE_NAME_1 + message);
            };
            channel.basicConsume(FanoutExchange.QUEUE_NAME_1,true,consumer1, consumerTag -> {});

            //Callback for reading from Queue -2
            DeliverCallback consumer2 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From" + FanoutExchange.QUEUE_NAME_2 + message);
            };
            channel.basicConsume(FanoutExchange.QUEUE_NAME_2,true,consumer2, consumerTag -> {});

            //Callback for reading from Queue -3
            DeliverCallback consumer3 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From" + FanoutExchange.QUEUE_NAME_3 + message);
            };
            channel.basicConsume(FanoutExchange.QUEUE_NAME_3,true,consumer3, consumerTag -> {});


        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

4.Main
package com.tata.amqp.exchange.fanout;

public class MainFanout {
    public static void main(String[] args) throws InterruptedException {
        //Create Exchange,Queues,Bindings will be ready
        FanoutExchange fanoutExchange = new FanoutExchange();
        //Publish
        Producer producer = new Producer();
        producer.publish();

        Consumer consumer = new Consumer();
        consumer.receive();

        Thread.sleep(1000);


    }
}
..............................................................................................

				Topic Exchange
..............................................................................................

What is Topic Exchange?

 A topic exchange is an exchange which routes messages to queues based on the wild card 
match between routing key and routing pattern specified during the binding of the queue.

Exchange after receiving message, exchange try to match the "routing key with binding routing pattern" of all the queue bound to it.


Routing Patterns:
  -Routing patterns are wild cards

 *  
  -> It is used to match a word at a specific position in the routing key
 for eg routing key is
  "asia.india" will match to the routing keys where the first word is asia and the second word is india like "asia.india.delhi" or "asia.india.mumbai" etc...

 
 #
 -it is used to match zero or more words, for example a routing pattern of 

  "asia.india#" will match to the routing keys that begin with "asia.india" "asia.china"

...........................................................................................

Topic Exhange

Steps :

1.Utitlity code please refere previous programms

2.Exchange Creation
package com.tata.amqp.exchange.topic;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.ExchangeType;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class TopicExchange {

    //Exchange
    public static final String EXCHANGE_NAME = "topic-exchange";

    //Queue
    public static final String QUEUE_NAME_1 = "topic-queue-1";
    public static final String QUEUE_NAME_2 = "topic-queue-2";
    public static final String QUEUE_NAME_3 = "topic-queue-3";

    //Routing Patterns and  Keys
    public static String ROUTING_PATTERN_1 = "asia.china.*";
    public static String ROUTING_PATTERN_2 = "asia.china.#";
    public static String ROUTING_PATTERN_3 = "asia.*.*";

    //keys
    public static String ROUTING_KEY_1 = "asia.china.nanjing";
    public static String ROUTING_KEY_2 = "asia.china";
    public static String ROUTING_KEY_3 = "asia.china.beijing";
    public static String ROUTING_KEY_4 = "asia.india.mumbai";

    public void createExchangeAndQueue(){

        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();

            //Exchange
            channel.exchangeDeclare(EXCHANGE_NAME, ExchangeType.TOPIC.getExchangeName(),true);

            //First Queue
            channel.queueDeclare(QUEUE_NAME_1,true,false,false,null);
            channel.queueBind(QUEUE_NAME_1,EXCHANGE_NAME,ROUTING_PATTERN_1);

            //Second Queue
            channel.queueDeclare(QUEUE_NAME_2,true,false,false,null);
            channel.queueBind(QUEUE_NAME_2,EXCHANGE_NAME,ROUTING_PATTERN_2);

            //Third Queue
            channel.queueDeclare(QUEUE_NAME_3,true,false,false,null);
            channel.queueBind(QUEUE_NAME_3,EXCHANGE_NAME,ROUTING_PATTERN_3);



            channel.close();
            connection.close();
        } catch (IOException | TimeoutException e) {
            e.printStackTrace();
        }
    }




}

2.Publisher

package com.tata.amqp.exchange.topic;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class Publisher {

    //Messages
    private final static String MESSAGE_1 = "FIRST topic message";
    private final static String MESSAGE_2 = "SECOND topic message";
    private final static String MESSAGE_3 = "THIRD topic message";
    public void publish() {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();

            //publish message:
            channel.basicPublish(TopicExchange.EXCHANGE_NAME,TopicExchange.ROUTING_KEY_1,null,MESSAGE_1.getBytes());
            System.out.println("Message Sent " + MESSAGE_1 );

            channel.basicPublish(TopicExchange.EXCHANGE_NAME,TopicExchange.ROUTING_KEY_2,null,MESSAGE_2.getBytes());
            System.out.println("Message Sent " + MESSAGE_2 );

            channel.basicPublish(TopicExchange.EXCHANGE_NAME,TopicExchange.ROUTING_KEY_3,null,MESSAGE_3.getBytes());
            System.out.println("Message Sent " + MESSAGE_3 );

            channel.basicPublish(TopicExchange.EXCHANGE_NAME,TopicExchange.ROUTING_KEY_4,null,"India -Mumbai".getBytes());
            System.out.println("Message Sent " + "India-Mumbai" );

            channel.basicPublish(TopicExchange.EXCHANGE_NAME,TopicExchange.ROUTING_KEY_4,null,"Singapore".getBytes());
            System.out.println("Message Sent " + "Singapore" );

            channel.close();
            connection.close();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }
}

3.Consumer
package com.tata.amqp.exchange.topic;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;
import com.rabbitmq.client.Delivery;
import com.tata.amqp.basic.RabbitMQConnectionUtil;
import com.tata.amqp.exchange.fanout.FanoutExchange;

import java.io.IOException;

public class Consumer {
    public void receive() {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            DeliverCallback consumer1 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From Queue 1 " + message);
            };
            channel.basicConsume(TopicExchange.QUEUE_NAME_1,true,consumer1,consumerTag -> {});

            DeliverCallback consumer2 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From Queue 2 " + message);
            };
            channel.basicConsume(TopicExchange.QUEUE_NAME_2,true,consumer2,consumerTag -> {});

            DeliverCallback consumer3 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From Queue 3" + message);
            };
            channel.basicConsume(TopicExchange.QUEUE_NAME_3,true,consumer3,consumerTag -> {});

          // connection.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

Main :

package com.tata.amqp.exchange.topic;


public class MainTopic {
    public static void main(String[] args) {

        //Create queues and exchanges
        TopicExchange topicExchange = new TopicExchange();
        topicExchange.createExchangeAndQueue();

        //Publish message
        Publisher publisher = new Publisher();
        publisher.publish();
        //read  messages
        Consumer consumer = new Consumer();
        consumer.receive();

    }
}
.............................................................................................
				  Headers Exchanges
				Uses Message Headers
.............................................................................................

What is Header Exchange?
 A header exchange is an exchange which routes messages to Queues based on message header values instead of "Routing Key".

Producers adds some values in the form of "key-value"  pair in message header and sends to 
it headers Exchange.

After a receiving a message, Exchange try to match all or any based on "x-match" header value
with the binding value of all the queues bound to it.

...........................................................................................
Producer can add one special value in the header of the message called as "x-match".

"x-match"  can have two different values.
  "any"
	any means at least one of the headers key-value pairs must match with binding value of
the queue.

  "all"
      All the header key-value pairs must match.


Steps:

1.Basic api from the previous code

2.Header Exchange Creation

package com.tata.amqp.exchange.headers;


import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.ExchangeType;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class HeaderExchange {
    public static String EXCHANGE_NAME = "header-exchange";
    public static String QUEUE_NAME_1 = "header-queue1";
    public static String QUEUE_NAME_2 = "header-queue2";
    public static String QUEUE_NAME_3 = "header-queue3";

    //Routing Key
    public static String Routing_KEY = "";

    public void createExchangeAndQueue() {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();

            channel.exchangeDeclare(EXCHANGE_NAME, ExchangeType.HEADER.getExchangeName(), true);

            //Queue -1
            //Headers
            Map<String, Object> map = null;
            map = new HashMap<>();
            map.put("x-match", "any");
            map.put("First", "A");
            map.put("Fourth", "D");
            channel.queueDeclare(QUEUE_NAME_1, true, false, false, null);
            //Queuebinding
            channel.queueBind(QUEUE_NAME_1, EXCHANGE_NAME, Routing_KEY, map);

            //Queue2
            map = new HashMap<>();
            map.put("x-match", "any");
            map.put("Third", "C");
            map.put("Fourth", "D");
            channel.queueDeclare(QUEUE_NAME_2, true, false, false, null);
            //Queuebinding
            channel.queueBind(QUEUE_NAME_2, EXCHANGE_NAME, Routing_KEY, map);

            //Queue3
            map = new HashMap<>();
            map.put("x-match", "any");
            map.put("First", "A");
            map.put("Third", "C");
            channel.queueDeclare(QUEUE_NAME_3, true, false, false, null);
            //Queuebinding
            channel.queueBind(QUEUE_NAME_3, EXCHANGE_NAME, Routing_KEY, map);

            connection.close();

        } catch (IOException e) {
            e.printStackTrace();
        }

    }

}

2.Publishers

package com.tata.amqp.exchange.headers;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class Publisher {

    private final static String MESSAGE_1 = "First Header Message";
    private final static String MESSAGE_2 = "Second Header Message";
    private final static String MESSAGE_3 = "Third Header Message";

    public void publish() {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();

            //Meta Data -First Message
            AMQP.BasicProperties properties = null;
            Map<String, Object> map = null;
            map = new HashMap<>();
            //header values
            map.put("First", "A");
            map.put("Fourth", "D");
            //Basic properties carry many meta data to exchange.
            properties = new AMQP.BasicProperties();
            //injecting headers and its values into basicproperties
            properties = properties.builder()
                    .headers(map)
                    .build();
            //Publish message with Properties
            channel.basicPublish(HeaderExchange.EXCHANGE_NAME, HeaderExchange.Routing_KEY, properties, MESSAGE_1.getBytes());
            System.out.println("Message Sent " + MESSAGE_1);


            //Meta Data -First Message
            map = new HashMap<>();
            //header values
            map.put("Third", "C");
            //Basic properties carry many meta data to exchange.
            properties = new AMQP.BasicProperties();
            //injecting headers and its values into basicproperties
            properties = properties.builder()
                    .headers(map)
                    .build();
            //Publish message with Properties
            channel.basicPublish(HeaderExchange.EXCHANGE_NAME, HeaderExchange.Routing_KEY, properties, MESSAGE_2.getBytes());
            System.out.println("Message Sent " + MESSAGE_2);

            //Meta Data -First Message
            map = new HashMap<>();
            //header values
            map.put("First", "A");
            map.put("Third", "C");

            //Basic properties carry many meta data to exchange.
            properties = new AMQP.BasicProperties();
            //injecting headers and its values into basicproperties
            properties = properties.builder()
                    .headers(map)
                    .build();
            //Publish message with Properties
            channel.basicPublish(HeaderExchange.EXCHANGE_NAME, HeaderExchange.Routing_KEY, properties, MESSAGE_3.getBytes());
            System.out.println("Message Sent " + MESSAGE_3);


        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}

3.Consumers
package com.tata.amqp.exchange.headers;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;
import com.rabbitmq.client.Delivery;
import com.tata.amqp.basic.RabbitMQConnectionUtil;
import com.tata.amqp.exchange.topic.TopicExchange;

import java.io.IOException;

public class Consumer {

    public void receive(){
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            DeliverCallback consumer1 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From Queue 1 " + message);
            };
            channel.basicConsume(HeaderExchange.QUEUE_NAME_1,true,consumer1, consumerTag -> {});

            DeliverCallback consumer2 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From Queue 2 " + message);
            };
            channel.basicConsume(HeaderExchange.QUEUE_NAME_2,true,consumer2, consumerTag -> {});


            DeliverCallback consumer3 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From Queue 3 " + message);
            };
            channel.basicConsume(HeaderExchange.QUEUE_NAME_3,true,consumer3, consumerTag -> {});

            // connection.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

Main:
package com.tata.amqp.exchange.headers;

import com.rabbitmq.client.AMQP;
import com.tata.amqp.exchange.headers.HeaderExchange;
import com.tata.amqp.exchange.headers.Publisher;
import com.tata.amqp.exchange.topic.Consumer;

public class HeadersMain {
    public static void main(String[] args) {
        HeaderExchange headerExchange = new HeaderExchange();
        headerExchange.createExchangeAndQueue();

        Publisher publisher = new Publisher();
        publisher.publish();

        com.tata.amqp.exchange.topic.Consumer consumer = new Consumer();
        consumer.receive();


    }
}
////////////////////////////////////////////////////////////////////////////////////////////
				Queue And Message Properties
............................................................................................

Server Named Queues:
...................

According to AMQP protocal, broker can generate q unique queue name on behalf of an app.

In order to use this option we have to pass "" empty string as the queue name arg.

The same generated queue name can  be obtained by the subsequent methods in the same channel
by using empty string where  a queue name is expected.

The channel remembers last generated queue name.

-Server Named queues are usefull for temp message pushing and consuming. once the message is consumed, the queue will be deleted automatically.

package com.tata.amqp.queues;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;
import com.tata.amqp.basic.ExchangeType;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;

public class ServerNamedQueue {
    private static final String EXCHANGE_NAME = "server-namedExQueue";
    private static final String QUERY_NAME = ""; // IT must be empty string
    private static final String ROUTING_KEYS = "mykey";
    private static final String MESSAGE_1 = "Hello!!!";

    public static void main(String[] args) {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            channel.exchangeDeclare(EXCHANGE_NAME, ExchangeType.DIRECT.getExchangeName(), true);

            //Ask the Server to create and give Queue Name: Server Generated Queue
            String queueName = channel.queueDeclare().getQueue();
            channel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEYS);

            //publish message
            channel.basicPublish(EXCHANGE_NAME, ROUTING_KEYS, null, MESSAGE_1.getBytes());

            DeliverCallback consumer = (consumerTag, delivery) -> {
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println(message);
                try {
                    Thread.sleep(5000);
                    //for deleting queue once the data is consumed
                    connection.close();

                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            };
            //consume message;
            channel.basicConsume(queueName, true, consumer, consumerTag -> {
            });


        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
//////////////////////////////////////////////////////////////////////////////////////////////
					Durablity
.............................................................................................

Durability:
  Keep things perment.

In rabbitmq, if server/node reboots , then there is possiblity we may loose exchange,queue,message.

In order to maintain persistency, we can set durability property on Exchange and queues

Durability
  - durable - keeps things permanent even after server restarts
  - Tranient -  Deletes after server restarts.


-Exchange:

Lab:

1. open management console, try to create Exchange with durable and transient properties
and restart server and have a look at.

2.via coding
package com.tata.amqp.queues;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;
import com.tata.amqp.basic.ExchangeType;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;

public class DurableExchange {
    private static final String EXCHANGE_NAME = "server-namedExQueue";

    public static void main(String[] args) {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            channel.exchangeDeclare(EXCHANGE_NAME, ExchangeType.DIRECT.getExchangeName(), true);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

DurableQueues:

package com.tata.amqp.queues;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;

public class DurableQueues {
    private static final String QUEUE_NAME = "tatadurable-queue";

    public static void main(String[] args) {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            //here second parameter is durable flag
            channel.queueDeclare(QUEUE_NAME, true, false, false, null);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
.............................................................................................
					Temporary Queues
.............................................................................................

-With some work loads queues are supposed to be short lived.
.

There are three ways to make queue and its messages deleted automatically.


-auto-delete queues
-Exclusive queues
-TTLS
.............................................................................................

Auto delete:

A auto delete will be deleted automatically when its last consumer is cancelled(basic.cancel)
or gone (connection is closed or lost TCP connection with server).

Use case : With basic.cancel method or channel.close and connection.close method

package com.tata.amqp.queues;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.ExchangeType;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class AutoDeleteQueuePublisher {
    private static final String EXCHANGE_NAME = "demo-exchange";
    private static final String QUEUE_NAME = "demo-queue";
    private static final String ROUTING_KEY = "demokey";

    public static void main(String[] args) {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            channel.exchangeDeclare(EXCHANGE_NAME,"direct",true);
            channel.queueDeclare(QUEUE_NAME,true,false,true,null);
            channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,ROUTING_KEY);

            String message= "Hello RabbitMQ";
            channel.basicPublish(EXCHANGE_NAME,ROUTING_KEY,null,message.getBytes());

            channel.close();
            connection.close();

        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }

}

package com.tata.amqp.queues;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class AutoDeleteQueueConsumer {
    private static final String QUEUE_NAME = "demo-queue";

    public static void main(String[] args) {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            DeliverCallback callback = (consumerTag, delivery) -> {
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Message Received " + message);
                System.out.println("Consumer Tag" + consumerTag);
                //if we call cancel method,the node will delete queue , if it has been marked with auto
                //delete property true
               // channel.basicCancel(consumerTag);
            };
            channel.basicConsume(QUEUE_NAME,true,callback,consumerTag -> {});

            channel.close();
            connection.close();
        } catch (IOException | TimeoutException e) {
            e.printStackTrace();
        }

    }
}
.............................................................................................

Exclusive Queues:
.................
An exclusive queues are queues can be used to consume,purge, delete by cancelling channel or connection.

Exlusive queues are deleted when their declaring connection is close or gone.

Exlusive quues are server named.

package com.tata.amqp.queues;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class ExclusiveQueus {
    private static final String EXCHANGE_NAME = "demo-exchange";
    private static final String QUEUE_NAME = "demo-queue";
    private static final String ROUTING_KEY = "demokey";

    public static void main(String[] args) {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            channel.exchangeDeclare(EXCHANGE_NAME, "direct", true);

            //exclusive true
            channel.queueDeclare(QUEUE_NAME, true, true, true, null);
            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);
            String message = "Hello RabbitMQ";
            channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, null, message.getBytes());
            System.out.println(QUEUE_NAME + " " + EXCHANGE_NAME + "Message has been published");

            DeliverCallback callback = (consumerTag, delivery) -> {
                String result = new String(delivery.getBody(), "UTF-8");
                System.out.println("Message Received " + result);
                System.out.println("Consumer Tag" + consumerTag);
            };
            channel.basicConsume(QUEUE_NAME, true, callback, consumerTag -> {
            });
            Thread.sleep(5000);
            channel.close();

        } catch (IOException | InterruptedException | TimeoutException e) {
            e.printStackTrace();
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////

TTL - Time to Live
 Life time for queues and messages.
How long queue can be or message can be inside a queue?

............................................................................................
                                     TTL For Messages 
..............................................................................................

Queue Arugments:

-Can be set in the management console when queue is created.

args:
x-message-ttl - value
x-max-length-bytes
x-max-length
x-expires

-Via code

There are two ways

1.Arguments
2.AMQP.BasicProperties

Map<String,Object> pargs = new HashMap<>();
pargs.put("x-message-ttl",5000);
channel.queueDeclare("demoqueue",false,false,false,pargs);

public class TTLQueuesUsingArgs {
    private static final String EXCHANGE_NAME = "demo-exchange";
    private static final String QUEUE_NAME = "demo-queue";
    private static final String ROUTING_KEY = "demokey";

    public static void main(String[] args) {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            channel.exchangeDeclare(EXCHANGE_NAME, "direct", true);
            String message = "Hello RabbitMQ";

            Map<String, Object> queueArgs = new HashMap<>();
            queueArgs.put("x-message-ttl", 10000);
            channel.queueDeclare(QUEUE_NAME, true, false, false, queueArgs);
            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);

            channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, null, message.getBytes());
            System.out.println(QUEUE_NAME + " " + EXCHANGE_NAME + "Message has been published");
            channel.close();
            connection.close();

        } catch (IOException | TimeoutException e) {
            e.printStackTrace();
        }


    }
}
...........................................................................................
2.AMQP.BasicProperties

package com.tata.amqp.queues;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.concurrent.TimeoutException;


public class TTLQueuesUsingBasicProperties {
    private static final String EXCHANGE_NAME = "demo-exchange";
    private static final String QUEUE_NAME = "demo-queue";
    private static final String ROUTING_KEY = "demokey";

    public static void main(String[] args) {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            channel.exchangeDeclare(EXCHANGE_NAME, "direct", true);
            String message = "Hello RabbitMQ";

            channel.queueDeclare(QUEUE_NAME, true, false, false, null);
            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);

            //BasicProperties
            AMQP.BasicProperties props = new AMQP.BasicProperties()
                    .builder()
                    .expiration("10000")
                    .build();

            //pass props to publisher
            channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, props, message.getBytes());
            System.out.println(QUEUE_NAME + " " + EXCHANGE_NAME + "Message has been published");
            channel.close();
            connection.close();

        } catch (IOException | TimeoutException e) {
            e.printStackTrace();
        }


    }
}
.............................................................................................
					TTL Queues
.............................................................................................

-Queue will expire after a period of time only when they are not used(do not have consumers)
 This feature can be used along with the auto-delete property.

TTL + Autodelete = true

Property:
x-expiries
package com.tata.amqp.queues;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;

public class TTLQueueDeletion {
    private static final String EXCHANGE_NAME = "demo-exchange";
    private static final String QUEUE_NAME = "demo-queue";
    private static final String ROUTING_KEY = "demokey";

    public static void main(String[] args) {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            channel.exchangeDeclare(EXCHANGE_NAME, "direct", true);
            //Args
            Map<String, Object> queueArgs = new HashMap<>();
            queueArgs.put("x-expires", 10000);
            channel.queueDeclare(QUEUE_NAME, true, false, true, queueArgs);
            channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,ROUTING_KEY);

            String message= "Hello RabbitMQ";
            channel.basicPublish(EXCHANGE_NAME,ROUTING_KEY,null,message.getBytes());

            channel.close();
            connection.close();

        } catch (IOException | TimeoutException e) {
            e.printStackTrace();
        }

    }
}
............................................................................................
					  MAX Length
			 (How many messages a queue can contain)
.............................................................................................

How queues stores messages?
  A queue is a sequential data structure with two primary operations

-enque -  item can be added at the tail 
-dequeue - item can be removed from the head.

Queues are first in first out -FIFO.

Consuming message means removing message from the queue.

Message Removal From the queue based on ack property.

-Nack Message, requeue true
   -Message may or may not have been delivered to the consumer.

Consumer consumed message with Nack

Contex /Use cases we go with Nack

- if message is consumed by the consumer, but consumer wants not to delete the message from
the broker

  Consumer sends Nack(Negative Ack) and another property called requeue=true to the broker 
 
Broker will try to "requeue" the message.

.............

-Ack message requeue false

 The consumer says, message succefully proceed, delete that message from the queue.
..............................................................................................

How many(ready) messages a queue can contain before it starts to "drop them from its head"?

  x-max-length arguement


When we  publish lets say 10 messages, Queue contains last 5 messages only. first 5 messages to be discarded.

package com.tata.amqp.queues;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;

public class MaxLengthQueueArgPublisher {
    private static final String EXCHANGE_NAME = "demo-exchange";
    private static final String QUEUE_NAME = "demo-queue";
    private static final String ROUTING_KEY = "demokey";

    public static void main(String[] args) {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            channel.exchangeDeclare(EXCHANGE_NAME, "direct", true);
            Map<String, Object> queueArgs = new HashMap<>();
            queueArgs.put("x-max-length", 5);
           channel.queueDeclare(QUEUE_NAME, true, false, false, queueArgs);
           // channel.queueDeclare(QUEUE_NAME, true, false, false, null);

            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);

            for (int i = 1; i <= 10; i++) {
                String message = "Hello " + i;
                channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, null, message.getBytes());
                System.out.println(QUEUE_NAME + EXCHANGE_NAME + message + "has been published");
            }
            channel.close();
            connection.close();

        } catch (IOException | TimeoutException e) {
            e.printStackTrace();
        }

    }
}
............................................................................................

Similar x-max-length property, we have x-max-length-bytes
  
 The size of queue 10 byte, beyond that it will be dropped automatically.

  Map<String, Object> queueArgs = new HashMap<>();
  queueArgs.put("x-max-length-bytes", 5);
  Channel.queueDeclare(QUEUE_NAME, true, false, false, queueArgs);
............................................................................................         			  Overflow Behaviour
...........................................................................................

Sets the queue overflow behaviour.
This determines what happens to messages when the maximum length of a queue is reached.

Valid values are drop-head, reject-publish or reject-publish-dlx. The quorum queue type only supports drop-head and reject-publish.

drop-head- The head of the queue message can be deleted
Reject-publish - recently sent message will be discard
Reject-publish-dlx -  Rejection message to be a dead letter exchange.

 Map<String, Object> queueArgs = new HashMap<>();
 queueArgs.put("x-overflow", "reject-publish");

package com.tata.amqp.queues;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;


public class QueueOverFlowMaxLength {
    private static final String EXCHANGE_NAME = "demo-exchange";
    private static final String QUEUE_NAME = "demo-queue";
    private static final String ROUTING_KEY = "demokey";

    public static void main(String[] args) {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            channel.exchangeDeclare(EXCHANGE_NAME, "direct", true);
            Map<String, Object> queueArgs = new HashMap<>();
            queueArgs.put("x-max-length", 5);
            //queueArgs.put("x-overflow","drop-head");
            queueArgs.put("x-overflow","reject-publish");
            channel.queueDeclare(QUEUE_NAME, true, false, false, queueArgs);

            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);

            for (int i = 1; i <= 10; i++) {
                String message = i + "";
                channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, null, message.getBytes());
                System.out.println(QUEUE_NAME + EXCHANGE_NAME + message + "has been published");
            }
            channel.close();
            connection.close();

        } catch (IOException | TimeoutException e) {
            e.printStackTrace();
        }

    }
}


Client Code:

Open Management Console, Consume Messages using getMessage Options.


Overflow behaviour can be handled
 -by deleting messages
 -by not accepting messages


...........................................................................................
if i dont want to loose message in case overflow behaviour is happend
				Dead Letter Exchange Queue
........................................................................................

What is Dead Letter Exchange Queue?
 
 Messages from a queue can be dead lettered, that is republished to an exchange when any of the following events.

-The message is negatively ack by a consumer using basic.reject or basic.nack with request parameter set to false.

-The message expire using ttl property

-The message is droped due to max length /bytes execeed limit

Dead Letter exchanges are normal regular exchanges only.

Dead Letter exchange is mapped by application queue's arg.

 
Map<String, Object> queueArgs = new HashMap<>();
queueArgs.put("x-max-length", 5);
queueArgs.put("x-overflow","reject-publish-dlx");
queueArgs.put("x-dead-letter-exchange","exchange-name"); 
queueArgs.put("x-dead-letter-routing-key","myroutingkey")       
channel.queueDeclare(QUEUE_NAME, true, false, false, queueArgs);


Publisher------------Exchange-----Queue----Overflow---routingKey--DeadLetterExchange---binding------DeadLetterExchangQ1,DeadLetterExchangeQ2..


Using Managment Console:

Steps : 

1.create Exchange 
  - myexchange1 - for application publisher
  - dlx1 - for DeadLetter Exchange.


2.Create Quque
  - myqueue1  - for application
	durable
    args
	x-dead-letter-exchange     dlx1
   	x-dead-letter-routing-key  dlx.timeout.test1
        x-message-ttl		   2000

3.Queue binding with Exchange


3.publish message into Myexchange1
  Have look at management dashboard, how messages are routed to deadletter exchange and queue.
.............................................................................................
				RPC - In micro services
..............................................................................................

What is RPC ?

RPC standards for Remote Procedure call.

Calling methods from one program to another program.

When we invoke methods across the runtime, network is involded ,we require protocal communication.

                Program -A -----talks to ----------------Program-B
		    |                                      |
		Runtime                                  Runtime
              (JVM/Javascript)                         (JVM/C++/Python/Javascript)

How to implement RPC Programming?

1.If runtime is same, JVM(java) -RMI,ORB(EJB) - very old 

2.if same runtime or different runtime(language) you can use -  gRpc
  gRpc uses tcp protocal for communication.

3.if same runtime or different runtime you can use message brokers - rabbitMQ,Kafka,Redis...


RPC Programming types:

1.sync programming
   caller(publisher) will be waiting until the consumer(worker) has processed the task.
   we other wise called "blocking"
2.async programming
   caller can continue his work, no need to wait for consumer result
   called as "non blocking".

How to implement async programming?

1.at language/framework/lib api level, eg nodejs,java-nio/vertx/quarkus....
  It is only vaild with in same runtime.

2.what if we need to run a function on  a remote machine and wait for the result?
  
  -Message Brokers,gRpc implementations.
..............................................................................................
				NonBlocking-Async RPC Programs in RabbitMQ

...............................................................................................

Implementation:

1.Client Interface -Publisher
2.Server interface - Consumer/worker.

RPC concepts in RabbitMQ:

1.callback Queue:
   A client sends a request message and a server replies with a response message.
  
In order to receive a response we need to send a 'callback' queue address with the request.

Publisher uses two queues:

1.For publishing message (request Message)

2.For getting response message (callback queue) - callback queue can be server named queue or programmed defined queue.

Syntax:

//callback queue creation
String callbackQueue= channel.queueDeclare().getQueue()

How to send callback queue along with message publish?

AMQP.BasicPropertie:

public AMQP.BasicProperties.Builder replyTo​(String replyTo)
  The method is used to register callbackqueu

AMQP.BasicProperties props =new AMQP.BasicProperties()
                               .Builder()
                               .replyTo(callbackQueue)
			       .build();

String messageQueue="rpc_queue";

channel.basicPublish("",messageQueue,props,message.getBytes());

Important Message properties:

1.content-Type
  to send what type of content - textplain,json
2.replyTo 
  to register callback queue
3.correlationId 
  Useful to corrleate RPC responses with requests.


Correlation Id:
...............
 As we discussed , we are creating new  callback for every RPC Request.

Client-1------CallbackQueue-1-------
Client-2------CallbackQueue-2-------
Client-2------CallbackQueue-3-------

The problm is now every client has its own queue, having received a response in that queue
it is not clear to which request the response belongs to.

We need response identification, that's where correlationid property is used.

We are going to set it to unique value for every request.Later when we receive a message inthe
callback queue we will look at this property and based on that we will able to match a response.
if we see unknown correlationId value, we may safely discard the message. if it does not belong to our request.

Client--Request------>|callback---------->queue---------->Caller

Client<---response<----Callback<----correlationId<-----Caller.

Problems In the RPC Server:

What if a server dies, after processing, during processing, how to send response to clients
-Ack comes into picture.

if no ack , the message again will requeued for further process.

...........................................................................................

Flow:

1.For RPC request, the Client sends a message with two properties, replyTo which is servernamed queue created just for request and corrleationId which is set to a unique value for every request, later used for processing responses.


2.The RPC server(worker) is waiting for requests on that queue. When a request appears, it does the job and sends a message with result back to client using the the reqly queue .

3.The client waits for data on the reply queue. when a message appears, it checks the corrleation id property. if it matches the value from the request it returns the response to the application.
............................................................................................

package com.tata.amqp.rpc;

import com.rabbitmq.client.*;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.UUID;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeoutException;

public class RPCPublisher implements AutoCloseable {
    private Connection connection;
    private Channel channel;
    private String requestQueueName = "rpc_queue";

    public RPCPublisher() {
        connection = RabbitMQConnectionUtil.getConnection();
        try {
            channel = connection.createChannel();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception {

        try (RPCPublisher rpcPublisher = new RPCPublisher()) {
            for (int i = 0; i < 100; i++) {
                String i_str = Integer.toString(i);
                System.out.println("Requesting fib " + i_str + " ");
                Thread.sleep(1000);
                String response = rpcPublisher.call(i_str);
                System.out.println("GOT " + response + " ");

            }
        } catch (IOException | TimeoutException | InterruptedException e) {
            e.printStackTrace();
        }

    }

    private String call(String message) throws IOException, InterruptedException {
        //send request : corrleationId,replyQue
        final String corrleationId = UUID.randomUUID().toString();
        //create queueName
        String replyQueueName = channel.queueDeclare().getQueue();
        AMQP.BasicProperties props = new AMQP.BasicProperties()
                .builder()
                .correlationId(corrleationId)
                .replyTo(replyQueueName)
                .build();

        channel.basicPublish("", requestQueueName, props, message.getBytes("UTF-8"));
        //Read Response
        //Store the responses into BlockingQueue datastructure
        //Blocking- dont close the current thread until the message is delivered.
        final BlockingQueue response = new ArrayBlockingQueue(1);
        //Listener for message
        DeliverCallback callback = (String consmerTag, Delivery delivery) -> {
            if (delivery.getProperties().getCorrelationId().equals(corrleationId)) {
                //store response into blocking queue
                try {
                    response.offer(new String(delivery.getBody(), "UTF-8"));
                } catch (UnsupportedEncodingException e) {
                    e.printStackTrace();
                }
            }
        };
        String consmerTag = channel.basicConsume(replyQueueName, true, callback, consumerTag -> {
        });
        String result = response.take().toString();
        //cancel the consumer
        channel.basicCancel(consmerTag);
        return result;
    }

    @Override
    public void close() throws Exception {
        connection.close();
    }
}

java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.rpc.RPCPublisher


RPC Server:
package com.tata.amqp.rpc;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;

public class RPCServer {
    private static final String RPC_QUEUE_NAME = "rpc_queue";

    private static int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        return fib(n - 1) + fib(n - 2);
    }

    public static void main(String[] args) {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            channel.queueDeclare(RPC_QUEUE_NAME, false, false, false, null);
            //delete messages
            channel.queuePurge(RPC_QUEUE_NAME);
            channel.basicQos(1);
            System.out.println("Server is Wating For Request");

            Object monitor = new Object();

            DeliverCallback callback = (ConsumerTag, delivery) -> {
                AMQP.BasicProperties props = new AMQP.BasicProperties()
                        .builder()
                        .correlationId(delivery.getProperties().getCorrelationId())
                        .build();
                String response = " ";
                try {
                    String message = new String(delivery.getBody(), "UTF-8");
                    int n = Integer.parseInt(message);
                    System.out.println(" Message  " + n );
                    response = response + fib(n);

                } catch (RuntimeException e) {

                } finally {
                    //republish the response to client
                    channel.basicPublish("", delivery.getProperties().getReplyTo(), props, response.getBytes("UTF-8"));
                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
                    synchronized (monitor) {
                        monitor.notify();
                    }
                }

            };

            channel.basicConsume(RPC_QUEUE_NAME, false, callback, (consumerTag, sig) -> {
            });

            //code for waiting indefintly
            while (true) {
                synchronized (monitor) {
                    try {
                        monitor.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.rpc.RPCPublisher
.............................................................................................
			    Task Queue In enterprise(RPC)
				    (Celery)
..............................................................................................

Celery is a task queue lib written in python.
Celery is task runner can be integrated with any message broker - rabbitmq,kafka,redis...


Steps:

1.Select Message Broker - RabbitMQ
2.install celery
   -python
   -pip 
3.install celery dependancies

install celery,ampq,redis modules

pip install celery
pip install amqp
pip install redis 
pip install eventlet


4.Test celery has been installed in system.

tasks:

tasks.py

from celery import Celery
from time import sleep

app = Celery('tasks', backend='redis://localhost', broker='amqp://guest:guest@localhost:5672/')

@app.task 
def reverse(text):
    sleep(5)
    return text[::-1]


Run Redis:
docker run -d redis


C:\session\tata\rabbitmq\CeleryTasks> celery -A tasks worker --loglevel=INFO -P eventlet

-------------- celery@LAPTOP-R2TGGFDL v5.1.2 (sun-harmonics)
--- ***** -----
-- ******* ---- Windows-10-10.0.19042-SP0 2021-07-16 12:37:57
- *** --- * ---
- ** ---------- [config]
- ** ---------- .> app:         tasks:0x1f0fbfc7220
- ** ---------- .> transport:   amqp://guest:**@localhost:5672//
- ** ---------- .> results:     redis://localhost/
- *** --- * --- .> concurrency: 12 (eventlet)
-- ******* ---- .> task events: OFF (enable -E to monitor tasks in this worker)
--- ***** -----
 -------------- [queues]
                .> celery           exchange=celery(direct) key=celery


[tasks]
  . tasks.reverse

[2021-07-16 12:37:57,401: INFO/MainProcess] Connected to amqp://guest:**@127.0.0.1:5672//
[2021-07-16 12:37:57,409: INFO/MainProcess] mingle: searching for neighbors
[2021-07-16 12:37:58,462: INFO/MainProcess] mingle: all alone
[2021-07-16 12:37:58,479: INFO/MainProcess] celery@LAPTOP-R2TGGFDL ready.


Sending tasks:

S C:\session\tata\rabbitmq\CeleryTasks> py
Python 3.9.5 (tags/v3.9.5:0a7dcbd, May  3 2021, 17:27:52) [MSC v.1928 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> from tasks import reverse
>>> result = reverse.delay('hello')
>>> result
<AsyncResult: dc2f6be0-74cb-47b8-b999-666ed25e921f>
>>> result.status
'SUCCESS'
>>> result.get()
'olleh'
>>> result = reverse.delay('hello')
>>> result
<AsyncResult: 06cc004c-071c-44d9-9fe5-c8b82a9cbb49>
>>> result.status
'PENDING'
>>> result.get()
'olleh'
>>> result
<AsyncResult: 06cc004c-071c-44d9-9fe5-c8b82a9cbb49>
>>> result.status
'SUCCESS'
>>> result = reverse.delay('hello')
>>> result
<AsyncResult: 74317f3c-cc72-4205-881a-7cf57db2023e>
>>> result.status
'SUCCESS'
>>> result = reverse.delay('hello')
>>> result = reverse.delay('hello')
>>> result = reverse.delay('suburamanian')

Check results in redis

root@3fd493ef2d15:/data# redis-cli
127.0.0.1:6379> keys *
 1) "celery-task-meta-faf8a861-a28a-4a5f-a803-0475578d8347"
 2) "celery-task-meta-ae768ff7-ff49-4fe4-9d89-b248b39780ad"
 3) "celery-task-meta-dc2f6be0-74cb-47b8-b999-666ed25e921f"
 4) "celery-task-meta-5253e658-5d17-4545-b2e3-5db746f3650c"
 5) "celery-task-meta-06cc004c-071c-44d9-9fe5-c8b82a9cbb49"
 6) "celery-task-meta-0222b9ee-83e3-4853-b11b-05b6db64c58c"
 7) "celery-task-meta-ec602328-b31d-469b-ad4b-17af5d70592d"
 8) "celery-task-meta-bbc83bc4-eb14-49a9-a20e-14a031317fd0"
 9) "celery-task-meta-8b1958b5-b0b7-4f76-878a-c45a301bf98e"
10) "celery-task-meta-74317f3c-cc72-4205-881a-7cf57db2023e"
11) "celery-task-meta-97bc2e0e-e7f2-4cfa-ac7d-bae53234beaf"
12) "celery-task-meta-09ca8ed7-a706-489e-abf0-3e57dd93d681"
13) "celery-task-meta-0235d181-7f40-4836-afcb-4950af7f009e"

127.0.0.1:6379> get celery-task-meta-89acd7d0-1c7e-45fc-9b8e-6bbe27ae449a
"{\"status\": \"SUCCESS\", \"result\": \"nainamarubus\", \"traceback\": null, \"children\": [], \"date_done\": \"2021-07-16T07:09:20.088612\", \"task_id\": \"89acd7d0-1c7e-45fc-9b8e-6bbe27ae449a\"}"
127.0.0.1:6379>
............................................................................................
				Scalling and HighAvaiablity
.............................................................................................
What is Clustering?
 A RabbitMq cluster is a logical grouping of one or servel nodes, each sharing users,virtualhosts,queues and exchanges, runtime parameters, other distribtued state


Why clustering?

-To avoid fail-overs
-To improve performance 


Cluster Implementation:

RabbitMQ supports different way of clustering.

1.Declaratively by listing cluster nodes in config file : via config file
2.Manually with rabbitmqctl
With plugins:
3.Declaratively using AWS(EC2) instance discovery plugin
4.Declaratively using Kubernetes discovery plugin
5.Declaratively consule based dicovery plugin
6.Declaratively etcd-based discovery plugin


Cluster Requirements:

in order form and setup cluster , there are certain requirements must meet.

1.Node names(identifiers)
 
 RabbitMQ nodes are identified each other in cluster by node names

Node Name Syntax:
 Node name contains two parts
prefix@hostname

rabbit@tata.messaging.svc.local
rabbit@containerName

-Node names must be unique.
rabbit1@hostame

2.HostName resolution

-RabbitMQ identifies nodes eatch other using domain names. either short or fully qualified(FQDNS).

-Hosts can be
  -DNS Records
  -/etc/hosts
  -container names

3.PORT Access

Rabbit MQ nodes bind to ports in order to accept client and CLI tool connections.
Internally Rabbit Uses tcp connections.

Port Range and its uses:
........................
4369 : It is used by rabbit dameon nodes and cli tools
5672,5671- used by clients.
25672 : inter node communication and cli tool communication
15672 :HTTP management port,http api , clients
etc...
...........................................................................................

Nodes in a cluster:
...................

1.Replication:

 Keeping the same state/data/queue/exchange across the nodes in the cluster.

2.Nodes are equal Peers:

 Some distributed systems have master and slave nodes.
 This is not available in RabbitMQ.
 All nodes in a RabbitMQ cluster are qual.
............................................................................................

Node Authentication:
....................

RabbitMQ Nodes , and Cli tools use a cookie to determine whether they are allowed to communicate with each other.
For two nodes to be able to communicate they must have the same shared secret called the 
"Erlang cookie".

The cookie is just a string of alphanumeric characters up to 255 characters in size.

Every cluster node must have the same cookie.

Erlang cookie is stored in a file.

if that file not available, server will try to create a cookie file and also generte cookie.

location of cookie file  /var/lib/rabbitmq/.erlang.cookie

Incase of docker and Kubernetes env, we have to generate cookie with help of "RABBITMQ_ERLANG_COOKIE"

.............................................................................................
				Cluster Setup:


Req:
-Docker desktop.

Basic steps:

1.create docker network
  Docker network is used for setup nodes, node communication.
 
> docker network create rabbits


2.Create rabbitmq container without management console.

docker run -d --rm --net rabbits --hostname rabbit-1 --name rabbit-1 rabbitmq:3.8

3.how to grab existing erlang cookie

docker exec -it rabbit-1 cat /var/lib/rabbitmq/.erlang.cookie

output: 
NSKDCNXVRZFBJEQXLKTC
.............................................................................................

Cluster setup:

Manually with rabbitmqctl:

Steps:

1.Start three nodes with management console.

node-1

docker run -d --rm --net rabbits --hostname rabbit-1 --name rabbit-1 -p 8081:15672 rabbitmq:3.8-management


docker run -d --rm --net rabbits --hostname rabbit-2 --name rabbit-2 -p 8082:15672 rabbitmq:3.8-management

docker run -d --rm --net rabbits --hostname rabbit-3 --name rabbit-3 -p 8083:15672 rabbitmq:3.8-management

  
Once if run these , open browser and check whether management console is running or not

http://localhost:8081
http://localhost:8082
http://localhost:8083
...........................................................................................
Cluster Status Verification:

We need rabbitmqctl command

>docker exec -it rabbit-1 rabbitmqctl

>docker exec -it rabbit-1 rabbitmqctl  cluster_status
Cluster status of node rabbit@rabbit-1 ...
Basics

Cluster name: rabbit@rabbit-1

Disk Nodes

rabbit@rabbit-1

Running Nodes

rabbit@rabbit-1

Versions

rabbit@rabbit-1: RabbitMQ 3.8.19 on Erlang 24.0.3

Maintenance status

Node: rabbit@rabbit-1, status: not under maintenance

Alarms

(none)

Network Partitions

(none)

Listeners

Node: rabbit@rabbit-1, interface: [::], port: 15672, protocol: http, purpose: HTTP API
Node: rabbit@rabbit-1, interface: [::], port: 15692, protocol: http/prometheus, purpose: Prometheus exporter API over HTTP
Node: rabbit@rabbit-1, interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication
Node: rabbit@rabbit-1, interface: [::], port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0

Feature flags

Flag: drop_unroutable_metric, state: enabled
Flag: empty_basic_get_metric, state: enabled
Flag: implicit_default_bindings, state: enabled
Flag: maintenance_mode_status, state: enabled
Flag: quorum_queue, state: enabled
Flag: user_limits, state: enabled
Flag: virtual_host_metadata, state: enabled

Like above we can test all nodes
docker exec -it rabbit-2 rabbitmqctl  cluster_status
docker exec -it rabbit-3 rabbitmqctl  cluster_status
.............................................................................................

Connecting all nodes:

Using Manual Process:Manually creating cluster.

if any node wants to join with cluster, they will loose all the data which has been stored.

In order to join node with cluster, we need to reset the node.

Note:
if all nodes to talk each other who needs "common cookie". if nodes have different cookies cant talk each other. 

In the previous setup, we had started server, have different cookies so those nodes cant particpate in cluster lets have cookie values

docker exec -it rabbit-1 cat /var/lib/rabbitmq/.erlang.cookie
LFLYARBMPYZTAJPLXNNM

docker exec -it rabbit-2 cat /var/lib/rabbitmq/.erlang.cookie
YJJXYPKYFDXXIJGZZIJG

docker exec -it rabbit-3 cat /var/lib/rabbitmq/.erlang.cookie
YXSDKTGXFDYFYWZHFULS

In order setup nodes having common cookie, first remove all started nodes

docker rm -f rabbit-1
docker rm -f rabbit-2
docker rm -f rabbit-3
.............................................................................................

Start all the nodes with common cookie

docker run -d --rm --net rabbits --hostname rabbit-1 --name rabbit-1 -p 8081:15672 -e RABBITMQ_ERLANG_COOKIE=LFLYARBMPYZTAJPLXNNM rabbitmq:3.8-management


docker run -d --rm --net rabbits --hostname rabbit-2 --name rabbit-2 -p 8082:15672 -e RABBITMQ_ERLANG_COOKIE=LFLYARBMPYZTAJPLXNNM rabbitmq:3.8-management

docker run -d --rm --net rabbits --hostname rabbit-3 --name rabbit-3 -p 8083:15672 -e RABBITMQ_ERLANG_COOKIE=LFLYARBMPYZTAJPLXNNM rabbitmq:3.8-management


Test all nodes having same cookie or not:

docker exec -it rabbit-1 cat /var/lib/rabbitmq/.erlang.cookie
LFLYARBMPYZTAJPLXNNM
PS C:\session\tata\rabbitmq> docker exec -it rabbit-2 cat /var/lib/rabbitmq/.erlang.cookie
LFLYARBMPYZTAJPLXNNM
PS C:\session\tata\rabbitmq> docker exec -it rabbit-3 cat /var/lib/rabbitmq/.erlang.cookie
LFLYARBMPYZTAJPLXNNM.

Now all nodes in the same network and having same cookie. so able to connect each other.

#join the rabbit-2

Steps for joing:

you have to use rabbitmqctl command in order perform these operations

1.stop application which is already running 

$docker exec -it rabbit-2 rabbitmqctl stop_app

RABBITMQ_ERLANG_COOKIE env variable support is deprecated and will be REMOVED in a future version. Use the $HOME/.erlang.cookie file or the --erlang-cookie switch instead.
Stopping rabbit application on node rabbit@rabbit-2 ...

2.Reset content inside node

$docker exec -it rabbit-2 rabbitmqctl reset
RABBITMQ_ERLANG_COOKIE env variable support is deprecated and will be REMOVED in a future version. Use the $HOME/.erlang.cookie file or the --erlang-cookie switch instead.
Resetting node rabbit@rabbit-2 ...

3.joining with cluster
 
$docker exec -it rabbit-2 rabbitmqctl join_cluster rabbit@rabbit-1
 RABBITMQ_ERLANG_COOKIE env variable support is deprecated and will be REMOVED in a future version. Use the $HOME/.erlang.cookie file or the --erlang-cookie switch instead.
Clustering node rabbit@rabbit-2 with rabbit@rabbit-1

4.Restart the app in order see management console and use all features

$docker exec -it rabbit-2 rabbitmqctl start_app

5.Check management console or command line to know the cluster information
docker exec -it rabbit-2 rabbitmqctl cluster_status


RABBITMQ_ERLANG_COOKIE env variable support is deprecated and will be REMOVED in a future version. Use the $HOME/.erlang.cookie file or the --erlang-cookie switch instead.
Cluster status of node rabbit@rabbit-2 ...
Basics

Cluster name: rabbit@rabbit-2

Disk Nodes

rabbit@rabbit-1
rabbit@rabbit-2

Running Nodes

rabbit@rabbit-1
rabbit@rabbit-2

Versions

rabbit@rabbit-1: RabbitMQ 3.8.19 on Erlang 24.0.3
rabbit@rabbit-2: RabbitMQ 3.8.19 on Erlang 24.0.3

Maintenance status

Node: rabbit@rabbit-1, status: not under maintenance
Node: rabbit@rabbit-2, status: not under maintenance

Alarms

(none)

Network Partitions

(none)

Listeners

Node: rabbit@rabbit-1, interface: [::], port: 15672, protocol: http, purpose: HTTP API
Node: rabbit@rabbit-1, interface: [::], port: 15692, protocol: http/prometheus, purpose: Prometheus exporter API over HTTP
Node: rabbit@rabbit-1, interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication
Node: rabbit@rabbit-1, interface: [::], port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0
Node: rabbit@rabbit-2, interface: [::], port: 15672, protocol: http, purpose: HTTP API
Node: rabbit@rabbit-2, interface: [::], port: 15692, protocol: http/prometheus, purpose: Prometheus exporter API over HTTP
Node: rabbit@rabbit-2, interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication
Node: rabbit@rabbit-2, interface: [::], port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0

Feature flags

Flag: drop_unroutable_metric, state: enabled
Flag: empty_basic_get_metric, state: enabled
Flag: implicit_default_bindings, state: enabled
Flag: maintenance_mode_status, state: enabled
Flag: quorum_queue, state: enabled
Flag: user_limits, state: enabled
Flag: virtual_host_metadata, state: enabled
...........................................................................................

#join the rabbit-3

docker exec -it rabbit-3 rabbitmqctl stop_app
docker exec -it rabbit-3 rabbitmqctl reset
docker exec -it rabbit-3 rabbitmqctl join_cluster rabbit@rabbit-1
docker exec -it rabbit-3 rabbitmqctl start_app
docker exec -it rabbit-3 rabbitmqctl cluster_status

............................................................................................

Setup new Node:

# Node start

docker run -d --rm --net rabbits --hostname rabbit-4 --name rabbit-4 -p 8084:15672 -e RABBITMQ_ERLANG_COOKIE=LFLYARBMPYZTAJPLXNNM rabbitmq:3.8-management

#join the rabbit-4

docker exec -it rabbit-4 rabbitmqctl stop_app
docker exec -it rabbit-4 rabbitmqctl reset
docker exec -it rabbit-4 rabbitmqctl join_cluster rabbit@rabbit-2
docker exec -it rabbit-4 rabbitmqctl start_app
docker exec -it rabbit-4 rabbitmqctl cluster_status
..............................................................................................
			Way 2 : Setting up Cluster via Config files
..............................................................................................

Why this approach?

When we are running rabbitmqq inside disposble container,When containers destroyed, rabbitmq
starts,who cant join cluster automatically. because there is no persistency eg if rabbit-4 deleted, again rabbit-4 cant rejoin the cluster.

Automatic Rejoining when container is destroyed and up
   Config file approach is good one.


in order to implement we need to delete all the containers which were running
docker rm -f rabbit-1
docker rm -f rabbit-2
docker rm -f rabbit-3
docker rm -f rabbit-4

Setup Req:

1.we need config file, where we need to define cluster configuration.

folder structure:

$cluster
   |
   config
     |
     rabbit-1
     rabbit-2
     rabbit-3

Inside rabbit-1

rabbitmq.conf

loopback_users.guest = false
listeners.tcp.default = 5672

cluster_formation.peer_discovery_backend = rabbit_peer_discovery_classic_config
cluster_formation.classic_config.nodes.1 = rabbit@rabbit-1
cluster_formation.classic_config.nodes.2 = rabbit@rabbit-2
cluster_formation.classic_config.nodes.3 = rabbit@rabbit-3



cluster_formation.peer_discovery_backend  :
  What type of discovery server, we are going to use to know the nodes.
Nodes communicate via this discovery server only.
 

We have to repeate the same configuration for all nodes.


docker run -d --rm --net rabbits `
-v ${PWD}/config/rabbit-1/:/config/ `
-e RABBITMQ_CONFIG_FILE=/config/rabbitmq `
-e RABBITMQ_ERLANG_COOKIE=WIWVHCDTCIUAWANLMQAW `
--hostname rabbit-1 `
--name rabbit-1 `
-p 8081:15672 `
rabbitmq:3.8-management

docker run -d --rm --net rabbits `
-v ${PWD}/config/rabbit-2/:/config/ `
-e RABBITMQ_CONFIG_FILE=/config/rabbitmq `
-e RABBITMQ_ERLANG_COOKIE=WIWVHCDTCIUAWANLMQAW `
--hostname rabbit-2 `
--name rabbit-2 `
-p 8082:15672 `
rabbitmq:3.8-management

docker run -d --rm --net rabbits `
-v ${PWD}/config/rabbit-3/:/config/ `
-e RABBITMQ_CONFIG_FILE=/config/rabbitmq `
-e RABBITMQ_ERLANG_COOKIE=WIWVHCDTCIUAWANLMQAW `
--hostname rabbit-3 `
--name rabbit-3 `
-p 8083:15672 `
rabbitmq:3.8-management

#NODE 1 : MANAGEMENT http://localhost:8081
#NODE 2 : MANAGEMENT http://localhost:8082
#NODE 3 : MANAGEMENT http://localhost:8083

.............................................................................................
In order to automate, remove  any container

$docker rm -f rabbit-3

Watch Management console or cluster status command

Start the Container again and see how the node joins with cluster automatically

docker run -d --rm --net rabbits `
-v ${PWD}/config/rabbit-3/:/config/ `
-e RABBITMQ_CONFIG_FILE=/config/rabbitmq `
-e RABBITMQ_ERLANG_COOKIE=WIWVHCDTCIUAWANLMQAW `
--hostname rabbit-3 `
--name rabbit-3 `
-p 8083:15672 `
rabbitmq:3.8-management

Have look at management console
..............................................................................................
				  Queue Mirroring
..............................................................................................

Why clustering?

In RabbitMQ , We store messages in queues.
If nodes goes down, queues not able to support for clients.
Thats what we need many nodes, we have to replicate queues across the nodes

Mirroring means replicating , which means keeping the same copy of the queue across the nodes.

Each mirrored queues consist of one leader replica and one or more mirrors(replicas).The leader is hosted on one node commonly referred as the leader node for that queue. Each queue has its own leader.

How Mirroring is configured.
 Mirroring parameters are configured using policies


What is policy?

 Policy is set of rules to add features to the queues.

Policy is set via regular expressions

A Policy matches one or more queues by name(using regx pattern) and contains a definition that ared added to the toltatal set of properties of the matches.

Policies:

High Availablity feature via policy:

rabbitmqctl set_policy      ha-all       "^ha\." '{"ha-mode":"all"}'
               |              |            |
            policy set     policyName     regex
 

rabbitmqctl set_policy ha-two "^two\." \
   '{"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"}'

In order enable mirroring , we need to enable plugin

 rabbitmq_federation plugin

docker exec -it rabbit-1 rabbitmq-plugins enable rabbitmq_federation 
docker exec -it rabbit-2 rabbitmq-plugins enable rabbitmq_federation
docker exec -it rabbit-3 rabbitmq-plugins enable rabbitmq_federation

Set policy via rabbitmq ctl:


rabbitmqctl set_policy ha-fed \
    ".*" '{"federation-upstream-set":"all", "ha-mode":"nodes", "ha-params":["rabbit@rabbit-1","rabbit@rabbit-2","rabbit@rabbit-3"]}' \
    --priority 1 \
    --apply-to queues

Create queues in any one of the node and see how mirroring happens.
.............................................................................................

Automatic fail overs:
.....................

docker rm -f rabbit-1

see how management console works...
.............................................................................................

Quorum Queues :

 Why and When

 - {Data Safety + High Availability} 

Classic Queues
   
  -{Less data Safety + High Availablity}

 During network partion - during master and slave promotion in case of node failures, there is possibility of data loss.

............................................................................................

Shovel Plugin:
 
To setup WAN wide cluster.
 Replicating across the regions
..................................................................................................






































				





