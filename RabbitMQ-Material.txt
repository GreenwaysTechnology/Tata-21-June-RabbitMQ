What and Why is rabbitMQ

Distributed Apps

Messaging and its standards

AMQP 

RabbitMQ
 Server infrastructure.

Programming with RabbitMQ.

-java,javascript,.net,python......

/////////////////////////////////////////////////////////////////////////////////////////////

What is Distributed Computing?

Distributed computing (or distributed processing) is the technique of linking together multiple computer servers over a network into a cluster, to share data and to coordinate processing power. Such a cluster is referred to as a “distributed system.

Application components

1.biz logic -----DataSource
2.user interface

Types of Distributed?


1.Main frame
   -Data access logic / Data sources
   -biz logic 
every thing kept inside one single maiframe

2.thin 
  clients - having small software which connects main frameworks


2.client -server 

  Server will hold data only -data source/database
  Client will hold biz logic
  
3.Tier /layered client- server model

 -single tier
   Server will hold data only -data source/database
   Client will hold biz logic
 -two tier client-server
    server will have biz logic and data
    clients will have only user interfaces

 - three tier client-server arch 
      
     server will have biz logic  +data sources
     client will have biz logic - user interface  +biz logic  

after 1995 : introduction web

 -n tier client server arch

    server is broken into multiple servers
	
	  -webserver
          -app server will  have biz logic
          -database servers will have only datasources
          -middlewares will have brokers like rabbit mq.
          -clients will have ui 

/////////////////////////////////////////////////////////////////////////////////////////////

Distributed App design:

1.Old Distributed App we call monolithic.
2.new distributed app we call microservices.


Monolith:

 One App 
    --Orders
    --Customers
    --Payments
    --Inventory
   etc......

-single language -java/.net/python
-mostly single database -oracle,db2
-deployment - waterfall model -one go deployment
-down time is more
-vendor lock-in.

Program communication:
 Any app / any pl follows some patterns like object programming models

if your app is built on java, objects collabrate each other.

 Client-----Product----->Cart----->Order--Checkout-->Payment----|

Objects can talk each other for "Exchanging Message" : Message Passing.

Micro Services
 Single App is divided into multi domain apps

  -Order App
      -it has its own database
      -it has its own pl
      -its has its own team
     etc.....

  -Customer App

  -Inventory App


Remote Procedure Invocation:
.............................

 if programs are running as different applications, on different runtimes

 Objects on the same runtime - JVM

 Objects on different jvms - Distributed object communication.

Challanges:

 1. Process to Process communication - ipc

 2. Process are two machines - Network is involed

 3. Messages are passed via wire - Message passing protocals.

 4. Message Formats - BOTH Apps need to agree on same format - xml,json,protocalbuff....
  
IF SAME RUN TIME: JAVA

 -RMI - USED for JVM TO JVM

IF Different Runtime :Java to C++ : Enterprise Integration.

ORB - CORBA

Challanges in the RPC Based Middleware:

1. Both parties need to be available at the same point of time.

2. Programs are sync , communicate which leads blocking 

Blocking and Non Blocking:

 1. if a thread is blocked for a long running operation,os cant reuse that thread for 
   other operations.
    which leads more memory useage and it takes more cpu resource.

Non Blocking:

    "Having limitted no threads achive higher concurrency"

  lets say
      100 req =100 thread  = blocking mode

      100 req =  1 thread  =non blocking

      1 thread how can handle 100 request => async programming.

////////////////////////////////////////////////////////////////////////////////////////////

NON Blocking and Async Implementations:

1.Programming language /Framework /lib level
    eg:javascript
  eg:
     NIO,Netty,Vert.x,Spring With Netty/WebFlux


Language level communications are best , it increases speed.

It has its own drawbacks.

1. if caller is sending req,if callee not avaiable.

2. if caller is sending message need to persisted for period of time.

3. if messages are huge , i want to store only, i am  not interested process now.

4. if caller is sending message, he needs ack for message delivery.
/////////////////////////////////////////////////////////////////////////////////////////////
				MOM
                       Message Oriented Middlewares


Message-oriented middleware (MOM) is software or hardware infrastructure supporting sending and receiving messages between distributed systems. MOM allows application modules to be distributed over heterogeneous platforms and reduces the complexity of developing applications that span multiple operating systems and network protocols.

MOM Started in late 1990s for enterprise integration.


### Advantages:
Asynchronicity
Routing
Transformation

MOM implemntations who called  "Message Brokers"

Many Compaines who started building MOM Products

1.TIBCO Enterprise Message Service
2.Amazon SNS
3.IBM MQ
4.Microsoft MQ
5.RabbitMQ

etc...

Problems among MOM products

1.No standards


# Messaging Standards:

Historically, there was a lack of standards governing the use of message-oriented middleware that has caused problems. Most of the major vendors have their own implementations, each with its own application programming interface (API) and management tools.

# Advanced Message Queuing Protocol :Advanced Message Queuing Protocal

AMQP is the Internet Protocol for Business Messaging

The Advanced Message Queuing Protocol (AMQP) is an open standard for passing business messages between applications or organizations.  

It connects systems, feeds business processes with the information they need and reliably transmits onward the instructions that achieve their goals.

History:

AMQP was originated in 2003 by John O'Hara at JPMorgan Chase in London.
AMQP was conceived as a co-operative open effort. 

The initial design was by JPMorgan Chase from mid-2004 to mid-2006 and it contracted iMatix Corporation to develop a C broker and protocol documentation.

In 2005 JPMorgan Chase approached other firms to form a working group that included Cisco Systems, IONA Technologies, iMatix, Red Hat, and Transaction Workflow Innovation Standards Team (TWIST). 

In the same year JPMorgan Chase partnered with Red Hat to create Apache Qpid, initially in Java and soon after C++.

Independently, RabbitMQ was developed in Erlang by Rabbit Technologies, followed later by the Microsoft and StormMQ implementations.

The working group grew to 23 companies including Bank of America, Barclays, Cisco Systems, Credit Suisse, Deutsche Börse, Goldman Sachs, HCL Technologies Ltd, Progress Software, IIT Software, INETCO Systems Limited, Informatica (including 29 West), JPMorgan Chase, Microsoft Corporation, my-Channels, Novell, Red Hat, Software AG, Solace Systems, StormMQ, Tervela Inc., TWIST Process Innovations ltd, VMware (which acquired Rabbit Technologies) and WSO2.


AMQP certified by In August 2011, the AMQP working group announced its reorganization into an OASIS member section.

/////////////////////////////////////////////////////////////////////////////////////////////


Where is AMQP Protocal?

The AMQP  protocol is used by Microsoft Azure Service Bus, Service Bus for Windows Server, Azure Event Hubs, Azure IoT Hub, and by numerous open source projects like Apache Qpid, Apache ActiveMQ, and Apache Apollo, as well as by commercial messaging products of other vendors like JBoss A-MQ, RedHat MRG, SwiftMQ, and IBM MQLight.


## Key Capabilities

AMQP connects across:

Organizations – applications in different organizations
Technologies – applications on different platforms
Time – systems don’t need to be available simultaneously
Space – reliably operate at a distance, or over poor networks


Business Case

The main reasons an enterprise will chose AMQP over proprietary alternatives are:

Realize the savings commoditization brings; remove vendor lock-in
Connect applications on different platforms; choose the right platform for the job
Connect to business partners using a full featured open standard; remove technical barriers to trade 
Position for innovations built upon the foundation of AMQP

Key Features
AMQP was designed with the following main characteristics as goals:

Security
Reliability
Interoperability
Standard
Open

Versions:
0.8
0.9
0.9.1 - RabbitMQ written
0.10
1.0 -Latest
////////////////////////////////////////////////////////////////////////////////////////////

                                       AMQP Spec

Before getting into.

Any Protocal(http,tcp,smtp) , is based on specifications(ideas -how it works) - functional
and tech req.

Protocal is implemented by using programming language. every protocal is program.

http is written in c, http is c program.

AQMP is also spec, can be written in any language - erlang,c



Protocal Architecture:


The AMQP protocol is a binary protocol with modern features: it is multi-channel, negotiated,
asynchronous, secure, portable, neutral, and efficient. AMQP is usefully split into two layers:


+------------------Functional Layer----------------+
| |
| Basic Transactions Exchanges Message queues |
| |
+--------------------------------------------------+
+------------------Transport Layer-----------------+
| |
| Framing Content Data representation |
| |
| Error handling Heart-beating Channels |
| |
+--------------------------------------------------+

The functional layer defines a set of commands (grouped into logical classes of functionality) that do useful work on behalf of the application.

The transport layer that carries these methods from application to server, and back, and which handles channel multiplexing, framing, content encoding, heart-beating, data representation, and error handling.


General Architecture:

AMQ Model Architecture



what a middleware server is /Server?

it is a data server that accepts messages and does two main things with them, 

it routes them to different consumers depending on arbitrary criteria, and it buffers them in memory or on disk when consumers are not able to accept them fast enough


In a pre-AMQP server these tasks are done by monolithic engines that implement specific types of routing and buffering. The AMQ model takes the approach of smaller, modular pieces that can be combined in more diverse and robust ways. It starts by dividing these tasks into two distinct roles:

1. The exchange, which accepts messages from producers and routes them message queues.

2. The message queue, which stores messages and forwards them to consumer applications.

There is a clear interface between exchange and message queue, called a "binding".



AMQP provides runtime-programmable semantics, through two main aspects:

Who can create Exchange and Queues?

 - At Server level by Server admins
 - By The application Programmers


1. The ability at runtime via the protocol to create arbitrary exchange and message queue types.

2. The ability at runtime via the protocol to wire exchanges and message queues together to create any required message-processing system.


The Message Queue:
.................

A message queue stores messages in memory or on disk, and delivers these in sequence to one or more consumer applications.


Message queues are message storage and distribution entities. Each message queue
is entirely independent and is a reasonably clever object..


A message queue has various properties: private or shared, durable or temporary, client-named or servernamed, etc

By selecting the desired properties we can use a message queue to implement conventional middleware entities such as:


A shared store-and-forward queue, which holds messages and distributes these between consumers on a round-robin basis. Store and forward queues are typically durable and shared between multiple consumers.

A private reply queue, which holds messages and forwards these to a single consumer.

Reply queues are typically temporary, server-named, and private to one consumer.

A private subscription queue, which holds messages collected from various "subscribed" sources, and forwards these to a single consumer.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
                                         
					RabbitMQ


What is RabbitMQ?
   RabbitMQ is the most widely deployed open source message broker.
   RabbitMQ is refence implementation of AMQP Protocal.
   RabbitMQ supports other messaging protocals
     -STOMP -The Simple Text Oriented Messaging Protocol
     -MQTT  - IOT messaging protocal.
   RabbitMQ is written Erlang


Erlang:
   As a highly performant, stable, and clusterable message broker, it’s no surprise that
RabbitMQ has found a home in such mission-critical environments as the centerpiece
of large-scale messaging architectures.

It was written in Erlang, the telco-grade, functional programming language designed at the Ericsson Computer Science Laboratory in the mid-to-late 1980s.

 Erlang was designed to be a distributed, fault-tolerant, soft real-time system for applications that require 99.999% uptime.

 As a language and runtime system, Erlang focuses on lightweight processes that pass messages between each other, providing a high level of concurrency with no shared state.


Erlang’s design, which focused on concurrent processing and message passing, made
it a natural choice for a message broker like RabbitMQ:

As an application, a message broker maintains concurrent connections, routes messages, and manages their states.

In addition, Erlang’s distributed communication architecture makes it a natural for
RabbitMQ’s clustering mechanism. 

Servers in a RabbitMQ cluster make use of Erlang’s
inter-process communication (IPC) system, offloading the functionality that many competing
message brokers have to implement to add clustering capabilities.


RabbitMQ Low Level Architecture:
................................

 RabbitMQApp
    |
 Erlang VM


RabbitMQ Application Architecture:

Virtual Host or Vhost is logical representation of RabbitMQ services like Apache virtuals Hosts

"The term Virtual Host refers to the practice of running more than one web site (such as company1.example.com and company2.example.com) on a single machine"

RabbiMQ can run isloated services..

Each Vhost is collections of  Entities/Components

 1.Connections
 2.Exchanges
 3.Queues
 4.Bindings
 5.Security Settings - Users and its permissions


In Enterprise, We can have more than one machines/servers and each server can have more than one vhosts.

Resources can be shared across vhosts like queue sharings.
/////////////////////////////////////////////////////////////////////////////////////////////

RabbitMQ : Installation


There are two versions of RabbitMQ

1.Open source

2.Enterprise - CloudAMQP -https://www.cloudamqp.com/


RabbitMQ is highly portable , we can install any where.

Linux,BSD,UNIX : Debian,Ubuntu,RHEL,CentOS,Fedora,Solaris.
Windows : Chocolatey or installer ,binary

MACOS : Homebrew 

Elang/OTP for RabbitMQ

Docker

RabbitMQ ON kubernetes Cluster

Cloud :
  CloudAMQ
  AWS EC2
/////////////////////////////////////////////////////////////////////////////////////////////

Linux :

setup file

#!/bin/sh

## If sudo is not available on the system,
## uncomment the line below to install it
# apt-get install -y sudo

sudo apt-get update -y

## Install prerequisites
sudo apt-get install curl gnupg -y

## Install RabbitMQ signing key
curl -fsSL https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc | sudo apt-key add -

## Install apt HTTPS transport
sudo apt-get install apt-transport-https

## Add Bintray repositories that provision latest RabbitMQ and Erlang 23.x releases
sudo tee /etc/apt/sources.list.d/bintray.rabbitmq.list <<EOF
## Installs the latest Erlang 23.x release.
## Change component to "erlang-22.x" to install the latest 22.x version.
## "bionic" as distribution name should work for any later Ubuntu or Debian release.
## See the release to distribution mapping table in RabbitMQ doc guides to learn more.
deb https://dl.bintray.com/rabbitmq-erlang/debian bionic erlang
## Installs latest RabbitMQ release
deb https://dl.bintray.com/rabbitmq/debian bionic main
EOF

## Update package indices
sudo apt-get update -y

## Install rabbitmq-server and its dependencies
sudo apt-get install rabbitmq-server -y --fix-missing

/////////////////////////////////////////////////////////////////////////////////////////////

Afer installing , How to verify the rabbitmq server is running? How to start,stop,restart Rabbit MQ Server.


Two ways:

1.Using linux system command called "service"

2.Rabbit MQ server offers lot of tools.


Linux:

 $sudo service rabbitmq-server stop 
 $sudo service rabbitmq-server status
 $sudo service rabbitmq-server start
 $sudo service rabbitmq-server restart

2.RabbitMQ offers lot of tools

2.1.cli tools

1.rabbitmqctl for service management and general operator tasks

2.rabbitmq-diagnostics for diagnostics and health checking

3.rabbitmq-plugins for plugin management

4.rabbitmq-queues for maintenance tasks on queues, in particular quorum queues

5.rabbitmq-upgrade for maintenance tasks related to upgrades

2.2. Management UI Tool
     GUI Web Interface through which you can monitor

2.3. HTTP Api
       offers REST API, which returns server information, you can get and also pass to other applications
///////////////////////////////////////////////////////////////////////////////////////////

rabbitqctl :
  Tool for mananging Rabbit MQ nodes

Syntax:
   rabbitmqctl -options

rabbitmqctl [--node <node>] [--timeout <timeout>] [--longnames] [--quiet] <command> [<command options>]

rabbitmqctl [-n <node>] [-t <timeout>] [-l] [--quiet] <command> [<command options>]

Every RabbitMQ Server starts with default Node Name..

Name : rabbit@target-hostName

How to start RabbitMQ server?

1.Via System service command

2.Via rabbitmq binary command
   sudo rabbitmq-server 

Mode of Server Startup :

1. log mode

 sudo rabbitmq-server

  ##  ##      RabbitMQ 3.8.2
  ##  ##
  ##########  Copyright (c) 2007-2019 Pivotal Software, Inc.
  ######  ##
  ##########  Licensed under the MPL 1.1. Website: https://rabbitmq.com

  Doc guides: https://rabbitmq.com/documentation.html
  Support:    https://rabbitmq.com/contact.html
  Tutorials:  https://rabbitmq.com/getstarted.html
  Monitoring: https://rabbitmq.com/monitoring.html

  Logs: /var/log/rabbitmq/rabbit@ip-172-31-3-18.log
        /var/log/rabbitmq/rabbit@ip-172-31-3-18_upgrade.log

  Config file(s): (none)

  Starting broker... completed with 0 plugins.

After starting : You can check status

$sudo rabbitmqctl status


2. Detached Mode
  $ sudo rabbitmq-server -detached
Warning: PID file not written; -detached was passed.

After starting : You can check status

$sudo rabbitmqctl status

Shudown the server and check the status.

$sudo rabbitmqctl shutdown

$sudo rabbitmqctl status
/////////////////////////////////////////////////////////////////////////////////////////////
How to view Management Information?

//////////////////////////////////////////////////////////////////////////////////////////

How to install Rabbit In Windows?

windows binary

or 

choco install rabbitmq
.............................................................................................

rabbit MQ Boot Process:
.......................

$sudo rabbitmq-server start
          |
          loaded into main memory
               |
              Process(Erlang) is ready


 Since Rabbit Mq is server , which has default port 5672.

Rabbit MQ server mostly powered with configurations.


$sudo rabbitmq-server start
          |
          loaded into main memory
               |
              Process(Erlang) is ready
                |
                starts reading a configuration file
                        /etc/rabbitmq

Lab : 
1.Testing config files
  $ls -l /etc/rabbitmq

 by default there will be no files , empty


$sudo rabbitmq-server start
          |
          loaded into main memory
               |
              Process(Erlang) is ready
                |
                starts reading a configuration file
                        /etc/rabbitmq

Under this folder you can have three major configuration files, which need to be created
manually.

1.rabbitmq-env.conf

$sudo rabbitmq-server start
          |
          loaded into main memory
               |
              Process(Erlang) is ready
                |
                starts reading a configuration file
                        /etc/rabbitmq/rabbitmq-env.conf --entry file where major 
RabbitMQ configurations are found.

 But we have seen no such file , found. then how rabbit mq works.

    ->RabbitMQ has distributed default settings along with rabbitmq server.




$cat /etc/rabbitmq/rabbitmq-env.conf
# Defaults to rabbit. This can be useful if you want to run more than one node
# per machine - RABBITMQ_NODENAME should be unique per erlang-node-and-machine
# combination. See the clustering on a single machine guide for details:
# http://www.rabbitmq.com/clustering.html#single-machine
#NODENAME=rabbit

# By default RabbitMQ will bind to all interfaces, on IPv4 and IPv6 if
# available. Set this if you only want to bind to one network interface or#
# address family.
#NODE_IP_ADDRESS=127.0.0.1

# Defaults to 5672.
#NODE_PORT=5672


The default Settings for RabbitMQ:

1.Node
   Node is logical representation machine,on which rabbitmq application are running
2.Port
   Node is running on default port is 5672
3.Default log file
   /var/log/rabbitmq

Lab verify log files

$ls -l /var/log/rabbitmq
/////////////////////////////////////////////////////////////////////////////////////////////

How to run multiple rabbitmq server or  How to change rabbitmq server node name,port no from defalult settings?

Condition :

1.Each server should run in different port
2.Each server must have unique name.


Solution :  

You have to supply node name and port no differntly when you start server.

RabbitMQ can be configured by using three configurations

1.The first way is to use the RabbitMQ environment variables that lie on the environment variables of the operating system.

2.the second way is through the configuration file provided by RabbitMQ.
   rabbitmq.conf

3.the last way is to use runtime parameters
   A special runtime parameters are supplied to rabbitmq server when server runngi


Environment Variables:

 Environment variables are supplied by RabbitMQ-Built in.

Environment variables are configured 
         1.inside rabbitmq-env.conf file : static configuration
         2.during server startup via commandline.


common environment variables
*****************************

RABBITMQ_NODE_IP_ADDRESS:
	Change this if you only want to bind to one network interface. Binding to two or more interfaces can be set up in the configuration file.
	Default: an empty string, meaning "bind to all network interfaces".

RABBITMQ_NODE_PORT	
	Default: 5672.

RABBITMQ_NODENAME
	The node name should be unique per Erlang-node-and-machine combination. To run multiple nodes, see the clustering guide.
	Default:
	Unix*: rabbit@$HOSTNAME
	Windows: rabbit@%COMPUTERNAME%

RABBITMQ_CONFIG_FILE
	Main RabbitMQ config file path.

RABBITMQ_ADVANCED_CONFIG_FILE
	"Advanced" (Erlang term-based) RabbitMQ config file 

RABBITMQ_CONF_ENV_FILE
	Location of the file that contains environment variable definitions (without the RABBITMQ_ prefix).
   default
	Ubuntu and Debian: /etc/rabbitmq/rabbitmq-env.conf

RABBITMQ_MNESIA_BASE
	This base directory contains sub-directories for the RabbitMQ server's node database, message store and cluster state files, one for each node, unless RABBITMQ_MNESIA_DIR is set explicitly.

  default:
	Ubuntu and Debian packages: /var/lib/rabbitmq/mnesia/

RABBITMQ_MNESIA_DIR
	The directory where this RabbitMQ node's data is stored. This s a schema database, message stores, cluster member information and other persistent node state.

RABBITMQ_PLUGINS_DIR
	The list of directories where plugin archive files are located and extracted from. This is PATH-like variable, where different paths are separated by an OS-specific separator (: for Unix, ; for Windows). Plugins can be installed to any of the directories listed here. Must not contain any characters mentioned in the path restriction section.

	Ubuntu and Debian packages: /var/lib/rabbitmq/plugins

///////////////////////////////////////////////////////////////////////////////////////////

Lab:

 Server more rabbit mq servers

By default rabbit mq server starts in default 

$sudo rabbitmq-server 

  Default node

How to a new another server on the same host(server)

$sudo RABBITMQ_NODE_PORT=5673 RABBIT_NODENAME=tatanode rabbitmq-server -detached

How to connect rabbit mq server instance?

-rabbitmqctl tool
-app develoer
-management

rabbitmqctl [--node <node>] [--timeout <timeout>] [--longnames] [--quiet] <command> [<command options>]

Steps:
1. sudo RABBITMQ_NODE_PORT=5675 RABBITMQ_NODENAME=tatanode rabbitmq-server

sudo rabbitmqctl --node tatanode status

//////////////////////////////////////////////////////////////////////////////////////////////

Management UI:
.............

Env:

 - if you are in windows, after installing, you can access managment 
  localhost:15672
 - default user at local host is guest, guest

- if you are in linux, vm or bare , cloud

Plugins:
  Collection of utitiles , which are programs must be installed to view management dashboard
which is simple web application.

Plugins extend the rabbit mq server core functionality.

Features:
 -supports additional amqp protocal exchange types
 -monitoring tools
 -federation types

How to enable ,disable , install plugins

Syntax:

rabbitmq-plugins enable <plugin-name>

  
eg:
rabbitmq-plugins enable rabbitmq_peer_discovery_k8s


Disabling:

rabbitmq-plugins disable <plugin-name>
rabbitmq-plugins disable rabbitmq_top

$sudo rabbitmq-plugins directories -s

Plugin archives directory: /usr/lib/rabbitmq/plugins:/usr/lib/rabbitmq/lib/rabbitmq_server-3.8.14/plugins
Plugin expansion directory: /var/lib/rabbitmq/mnesia/rabbit@ip-172-31-4-201-plugins-expand
Enabled plugins file: /etc/rabbitmq/enabled_plugins

////////////////////////////////////////////////////////////////////////////////////////////

Use case: How to access management dashboard.

if you are in local host , you can access management console easily.

Note : 
 1.windows , no need of installing management_plugin , which installed by default

 2.Linux , we need to install management_plugin.
    sudo rabbitmq-plugins enable rabbitmq_management

How to access?

aws ec2 instance
  http://13.233.158.60:15672/

if it is local
  http:localhost//15672

Login creditionals:

if it is localhost domain.
 you can login using guest guest 

if it is remote login - like cloud aws/gcp..

you cant use guest user 


I need to create use admin user.

Authentication, Authorisation, Access Control
..............................................

How to create new user and offers  admin rights.

steps:

1. create user and password
syntax:
 sudo rabbitmqctl add_user userName password
 sudo rabbitmqctl add_user  root root

2. set user category-administrator
 syntax:
 sudo rabbitmqctl set_user_tags userName category
 
$ sudo rabbitmqctl set_user_tags admin administrator

To list created users;

~$ sudo rabbitmqctl list_users
Listing users ...
user    tags
admin   [administrator]
guest   [administrator]
root    [administrator]


If you delete users:
$rabbitmqctl delete_user 'username'
$rabbitmqctl delete_user 'admin'


Setting Permissions to access virtual Host:

To grant permissions to a user in a virtual host, use rabbitmqctl set_permissions:

sudo rabbitmqctl set_permissions -p "/" "root" ".*" ".*" ".*"


Full steps to create users

1.sudo rabbitmqctl add_user root root 
2.sudo rabbitmqctl set_user_tags admin administrator
3.sudo rabbitmqctl set_permissions -p "/" "root" ".*" ".*" ".*"

///////////////////////////////////////////////////////////////////////////////

User Tags:

Comma-separated list of tags to apply to the user. Currently supported by the management plugin:

-management
	User can access the management plugin.

-policymaker
	User can access the management plugin and manage policies and parameters for the vhosts they have access to.

monitoring
	User can access the management plugin and see all connections and channels as well as node-related information.

administrator
		User can do everything monitoring can do, manage users, vhosts and permissions, close other user's connections, and manage policies and parameters for all vhosts.
///////////////////////////////////////////////////////////////////////////////////////////

Virtual Hosts:
.............

Virtual Host is management web application.
Which consits of Connections,Exchanges,Queues,Users and permissions.

Virtual Hosts are similar to another virtual hosts present in web containers like apache, nginx.

How to virtual hosts in RabbitMQ can be created and deleted using 

->rabbitmqctl cli tool
->via HTTP rest apis

Logical and Physical Separation:
.................................

-Vhosts never separte RabbitMQ server physically.
 means that many vhosts can run on single erlang process(server) process.

Client Connections And Vhosts:
...............................
A virtual host has a name. When an AMQP 0-9-1 client connects to RabbitMQ, it specifies a vhost name to connect to. 

If authentication succeeds and the username provided was granted permissions to the vhost, connection is established

////////////////////////////////////////////////////////////////////////////////////////////

How to create Vhosts?

-via http api
-via rabbitmqctl tool
-via management dashboard tool.



CLI:

Adding new Vhost

$ sudo rabbitmqctl add_vhost product
Adding vhost "product" ...

Delete existing Vhost

$sudo rabbitmqctl delete_vhost product
Deleting vhost "product" ...
ubuntu@ip-172-31-4-201:~$

How to limit max client connections and max queues?

Client connections at  a time:

$rabbitmqctl set_vhost_limits -p vhost_name '{"max-connections": 256}'

How many queues we can create

$rabbitmqctl set_vhost_limits -p vhost_name '{"max-queues": 1024}'

////////////////////////////////////////////////////////////////////////////////////////////
                                     RabbitMQ Programming
............................................................................................

RabbitMQ is just middleware, can be connected with any programming language.

Java,C#,Python,Ruby,Node.js(javascript),Go,Swift....


Program Types:

1.Producer 
2.Consumer

Components:

1.Exchange

2.Queue

How clients are conntected with RabbitMQ Server?

As Per AQMP Protocal specification.

Clients(Producer && Consumer) talks to RabbitMQ Server via "TCP" Protocal.

Clients establish TCP connection with RabbitMQ Server.

Work Flow:

1.Client tries to connect server by sending TCP header
2.Server returns All Protocal messages
3.Client sends authentication info like username and password
4.Server responds auth success/failure
5.If success, Then select vhost
6.Once VHost ready, then it is ready to send or receive messages

According to this spec, Client Libs must Provide , Connection Implementation.


Channel:
 -It is Virtual Connection between your application and TCP



 jdbc:oracle:thin:Tcp/Ip:@localhost:1521:xe","system","oracle"
  |     |      |
protocal        subprotocal
       subprotocal

jdbc is universal protocal developed by sun micro system to talk to any datasources.

oracle -orcl
..............................................................................................

Programming : Java : amqp client.

Steps:

1.Create Maven Project
pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>RabbitMQJavaClientApp</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>
    <dependencies>
        <dependency>
            <groupId>com.rabbitmq</groupId>
            <artifactId>amqp-client</artifactId>
            <version>5.7.1</version>
        </dependency>
    </dependencies>
</project>
/////////////////////////////////////////////////////////////////////////////////////////

Step 2:

Establish Connection with RabbitMQ Server.

-ConnectionFactory:

com.rabbitmq.client.ConnectionFactory 
   -Convenience "factory" class to facilitate opening a Connection to an AMQP broker.

 ConnectionFactory factory = new ConnectionFactory();
 factory.setHost(hostName);
 factory.setPort(portNumber);
 factory.setVirtualHost(virtualHost);
 factory.setUsername(username);
 factory.setPassword(password);
 Connection conn = factory.newConnection();


ConnectionTest.java

package com.tata.amqp.basic;

import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class ConnectionTest {
    public static void main(String[] args) {
       ConnectionFactory connectionFactory = new ConnectionFactory();
       //set connection parameters
        connectionFactory.setHost("localhost");
        connectionFactory.setPort(5672);
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        connectionFactory.setVirtualHost("/");
        //connection
        try {
            Connection connection = connectionFactory.newConnection();
            System.out.println("Connection Established");
        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////

Send Message,Consume The Message:


Publisher ---------->Exchange------->Queue------>Consumer

Note: 
The publisher need to use explicit exchange, we dont need to create any exchange, we can
send message. 
RabbitMQ uses a default Exchange to send Message to the Queue.


In order to publish message:

-Exchange may be there - inside rabbitmq server -named Exchange.
-Queue must be there
    Queue can be created via client program - PUblisher
    Queue can be created inside RabbitMQ Server and use it.


How to create a Queue from java?

Using channel Object

channel.queueDeclare​(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map<String,​Object> arguments)


package com.tata.amqp.basic;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;

import java.io.IOException;

public class Producer {
    private static final String QUEUE_NAME = "hello";

    public static void main(String[] args) {

        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {

            Channel channel = connection.createChannel();
            //create queue
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            System.out.println(QUEUE_NAME + "Created ");


        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}




How to publish a message into created Queue?

basicPublish​(String exchange, String routingKey, boolean mandatory, boolean immediate, AMQP.BasicProperties props, byte[] body)


package com.tata.amqp.basic;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;

import java.io.IOException;

public class Producer {
    private static final String QUEUE_NAME = "hello";

    public static void main(String[] args) {

        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {

            Channel channel = connection.createChannel();
            //create queue
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            System.out.println(QUEUE_NAME + "Created ");

            //Publish Message
            String message = "Hello RabbitMQ";
            channel.basicPublish("",QUEUE_NAME,null,message.getBytes());
            System.out.println(" Sent " + message + " ");


        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

Consuming:

 Consumers are listeners, who listens for messages from the RabbitMQ.
 Consumer has to run like demon process.

 Messages May be published any time into Queue.

Context:

  1.Consumer may run as long process to wait for incoming messages
  2.Consumer when every start , who can read messages.

The message Processing is "Async" : Event Driven Programming.

How to implment async pattern to read messages in java?

 "Callback" Pattern.

RabbitMQ offers

com.rabbitmq.client

Interface DeliverCallback

Functional Interface:

This is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference.


package com.tata.amqp.basic;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;
import com.rabbitmq.client.Delivery;

import java.io.IOException;

public class Consumer {
    private static final String QUEUE_NAME = "hello";

    public static void main(String[] args) {
        //Same COnnection Information
        Connection connection = RabbitMQConnectionUtil.getConnection();
        //Channel
        try {
            Channel channel = connection.createChannel();
            //Get The Queue From where you want to Consume
            //IF the Queue does not exit it will create, other wise it will try to use existing queue
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            System.out.println("App is Waiting for Messages.. To exit press CTRL + C");
            //Lambda /Callback Function to read message:
            DeliverCallback callback = (String consumerTag, Delivery delivery) -> {
                //read message
                System.out.println("Message is Available");
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message : " + message);
            };
            //Consume : Syntax - 1 : declaring callback function separely and consume it
//            channel.basicConsume(QUEUE_NAME, true, callback, consumerTag -> {
//            });


            channel.basicConsume(QUEUE_NAME, true, (consumerTag, delivery) -> {
                //read message
                System.out.println("Message is Available");
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message : " + message);
            }, consumerTag -> {
            });

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

How to test , sending interactive messages to Consumers?

start two cmd ; publisher and another for consumer

java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.Producer "hey"

java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.Consumer
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
App is Waiting for Messages.. To exit press CTRL + C
Message is Available
Got Message : hey
.............................................................................................			 How to process Complex Messages with help of multiple Consumers


The previous use was how to send message from single Producer to Single Consumer.

Single Producer, Where mutiple Consumers.

  if one consumer is busy, then we cant send message to the same consumer again.We need to send a message to another consumer.


The way delivery message from producer to multiple consumers one by one called as "Task Queue"

What is Task Queue/Worker Queue?

 if consumer is doing resource insentive task such as image compression,video processing,pdf
creations,preparing large json reports etc.... after getting message(what to do-Task)

Producer has sent a message called "imageCompression" to RabbitMQ server , Where Consumer reads that message and accordingly starts task.. 

RabbitMQ server can push message to the COnsumer after completing long process, which makes queue will be full.

in order to avoid queue full , we can tell rabbit to distribute messages to multiple consumers.
  -Message can be distributed to many consumers 

How message to distribute 
   using Round Robin Dispatching algorthim.

How it works?
 if one message is delivered to one consumer,
 The next message will not be delivered to The consumer, rather which will be delivered to the consumer only

     m1--------------c1
     m2---------------c2
     
Round Robin:
...........

By default,RabbitMQ will send each message to  the single consumer, where consumer is too busy 
for accepting new message.


RabbitMQ can distribute messages to many consumers in round robin fashion.

How to implement Round Robin ?

 By default RabbitMQ server does not know to how to distribute messages to the consumers parallely.

channel.basicQos(prefetchCount) 

channel.basicQos(1)
   This tell rabbitmq not to give more than one message to a worker at a time.

How rabbitMQ server again can send messages to the worker (consumer) again?
  
   The worker Process replies with "ack"
 

Ack:
public abstract String basicConsume(String queue,
                                    boolean autoAck,
                                    com.rabbitmq.client.DeliverCallback deliverCallback,
                                    com.rabbitmq.client.CancelCallback cancelCallback)
queue – the name of the queue
autoAck – true if the server should consider messages acknowledged once delivered; false if the server should expect explicit acknowledgements
deliverCallback – callback when a message is delivered
cancelCallback – callback when the consumer is cancelled


Full Worker:

package com.tata.amqp.basic;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;


public class Worker {

    private static final String TASK_QUEUE_NAME = "task_queue";


    public static void main(String[] argv) throws Exception {
        final Connection connection = RabbitMQConnectionUtil.getConnection();
        //channel
        final Channel channel = connection.createChannel();

        channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);

        System.out.println(" [*] Waiting for messages. To exit press CTRL+C");
        //Implement Round Robin here
        channel.basicQos(1);

        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody(), "UTF-8");

            System.out.println(" [x] Received '" + message + "'");
            try {
                doWork(message);
            } finally {
                System.out.println(" [x] Done");
                //here send ack to rabbitmq server , so that rabbitmq server will re send fresh messages
                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
            }
        };
        channel.basicConsume(TASK_QUEUE_NAME, false, deliverCallback, consumerTag -> { });
    }

    private static void doWork(String task) {
        for (char ch : task.toCharArray()) {
            if (ch == '.') {
                try {
                    //fake delay in process.
                    Thread.sleep(1000);
                } catch (InterruptedException _ignored) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////

Producer Best Practices:

-Producer connection,channel must be closed , so that messages will be reached to RabbitMq
-More connection which leaks memory.


How to close Connection and Channel?

At of the code

 try{
   Connection
   Channel
 }
 catch(){

 }
 finally {
   channel.close()
   connection.close()
 }

Way -2

try-with-resources — introduced in Java 7 — allows us to declare resources to be used in a try block with the assurance that the resources will be closed after the execution of that block.

try (PrintWriter writer = new PrintWriter(new File("test.txt"))) {
    writer.println("Hello World");
}


package com.tata.amqp.basic;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.MessageProperties;

public class NewTask {

    private static final String TASK_QUEUE_NAME = "task_queue";

    public static void main(String[] argv) throws Exception {

        try (Connection connection = RabbitMQConnectionUtil.getConnection();
             Channel channel = connection.createChannel()) {
            channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);

            String message = String.join(" ", argv);

            channel.basicPublish("", TASK_QUEUE_NAME,
                    MessageProperties.PERSISTENT_TEXT_PLAIN,
                    message.getBytes("UTF-8"));
            System.out.println(" [x] Sent '" + message + "'");
        }
    }

}

///////////////////////////////////////////

How to Test?

Open three cmd 

two for consumers and one for producer



//Producer

C:\>java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.NewTask  First Message.
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
 [x] Sent 'First Message.'

C:\>java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.NewTask  Second Message..
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
 [x] Sent 'Second Message..'

C:\>java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.NewTask  Third Message...
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
 [x] Sent 'Third Message...'

C:\>java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.NewTask  Fourth Message....
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
 [x] Sent 'Fourth Message....'




Consumer:

C:\>java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.Worker
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
 [*] Waiting for messages. To exit press CTRL+C
 [x] Received 'First Message.'
 [x] Done
 [x] Received 'Third Message...'
 [x] Done


C:\>java -classpath C:\session\tata\RabbitMQ\RabbitMQJavaClientApp\target\classes;C:\Users\sasub\.m2\repository\com\rabbitmq\amqp-client\5.7.1\amqp-client-5.7.1.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar com.tata.amqp.basic.Worker
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
 [*] Waiting for messages. To exit press CTRL+C
 [x] Received 'Second Message..'
 [x] Done
 [x] Received 'Fourth Message....'
 [x] Done

//////////////////////////////////////////////////////////////////////////////////////////////
              				Exchanges
//////////////////////////////////////////////////////////////////////////////////////////////

-What is Exchange
-How to bind(connect) Exchange and Queue
     -Bindings : connector for exchange Queue
     -Routing Rules to select A particular queue
-How to connect/bind Producer and Exchange
     -RoutingKeys
-Types of Exchanges


What is Exchange?

 Exchange is a bridge between Producer Application and Queue.

 Exchange takes a message from the Producer application and routes it into 0...more queues.

Types OF exchanges

-Direct 
-Fanout
-Topic
-Headers

Any of type exchange can forward message to Queues

RabbitMQ Provides built in exchanges:

""          -AMQP Default Exchange   --- Direct
amq.direct  ---Direct
amq.fanout  --Fanout
amq.headers  -headers
amq.match    -headers
amq.topic   - topic 

Direct Exchange:

-A Direct Exchange is an exchange which routes messages to queues based on message routing key.

Keys:
-RoutingKey
-BindingKey

RoutingKey:

-The routingKey is a message attribute.

Message Attribute:
  Meta information sent to Exchange along with message(payload)

eg:
  if you send a message from browser/MobileApp/anyHttpClient App to webserver via http protocal.
  message sent  with many message properties(headers in http)
eg:
   accept:application/xml
   Authorization:admin

-The routingKey is added by the producer when message is sent 

.....................................................................................

How Exchange delivers Message to a Queue?

Generally a relationship is established by Exchange with Queues(1...many)

BindingKey:

 -Key used by Exchange to Route Messages to apporapriate Queues.

After receiving a message, exchange try to match the routing key with binding key of all the queues bound to it.
it routes messages the queue whose binding key is matched and if the match is not found, it ignored the message.
///////////////////////////////////////////////////////////////////////////////////////////

Direct Exchange Code:

1.Common code

package com.tata.amqp.basic;

public enum ExchangeType {

    DIRECT("direct"),
    TOPIC("topic"),
    FANOUT("fanout"),
    HEADER("headers");

    private final String exchangeName;

    ExchangeType(String exchangeName) {
        this.exchangeName = exchangeName;
    }

    public String getExchangeName() {
        return this.exchangeName;
    }

}

2.Connection Code

package com.tata.amqp.basic;


import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class RabbitMQConnectionUtil {
    public static Connection getConnection() {
        ConnectionFactory connectionFactory = new ConnectionFactory();
        //set connection parameters
        connectionFactory.setHost("localhost");
        connectionFactory.setPort(5672);
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        connectionFactory.setVirtualHost("/");
        //connection
        Connection connection = null;
        try {
            connection = connectionFactory.newConnection();
           // System.out.println("Connection Established");
        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
        return connection;
    }
}


Exchange and Queue Creation:

package com.tata.amqp.exchange.direct;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.ExchangeType;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

public class DirectExchange {
    //EXCHNAGE Name
    public static String EXCHANGE_NAME = "direct-exchange";
    //Queues
    public static String QUEUE_NAME_1 = "direct-queue-1";
    public static String QUEUE_NAME_2 = "direct-queue-2";
    public static String QUEUE_NAME_3 = "direct-queue-3";

    //Routing Keys
    public static String ROUTING_KEY_1 = "direct-key-1";
    public static String ROUTING_KEY_2 = "direct-key-2";
    public static String ROUTING_KEY_3 = "direct-key-3";

    public void createExchangeQueue() {
        try {
            Connection connection = RabbitMQConnectionUtil.getConnection();
            Channel channel = connection.createChannel();
            //Create Exchange
            channel.exchangeDeclare(EXCHANGE_NAME, ExchangeType.DIRECT.getExchangeName(), true);

            //Queue Creations
            //First Queue
            channel.queueDeclare(QUEUE_NAME_1,true,false,false,null);
            //Bind Queue and Exchange
            channel.queueBind(QUEUE_NAME_1,EXCHANGE_NAME,ROUTING_KEY_1);

            //Second Qeueue
            channel.queueDeclare(QUEUE_NAME_2,true,false,false,null);
            channel.queueBind(QUEUE_NAME_2,EXCHANGE_NAME,ROUTING_KEY_2);

            //Third Qeueue
            channel.queueDeclare(QUEUE_NAME_3,true,false,false,null);
            channel.queueBind(QUEUE_NAME_3,EXCHANGE_NAME,ROUTING_KEY_3);

            channel.close();
            connection.close();

        } catch (Exception e) {
            e.printStackTrace();
        } finally {

        }
    }


}

Publishing Message to Exchange

package com.tata.amqp.exchange.direct;


import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class Producer {
    private final static String MESSAGE_1 = "First Direct Message";
    private final static String MESSAGE_2 = "Second Direct Message";
    private final static String MESSAGE_3 = "Third Direct Message";

    public void publish() {
        try {
            Connection connection = RabbitMQConnectionUtil.getConnection();
            Channel channel = connection.createChannel();
            //Publish message into Exchange with right Routing Key.
            channel.basicPublish(DirectExchange.EXCHANGE_NAME, DirectExchange.ROUTING_KEY_1, null, MESSAGE_1.getBytes());
            System.out.println("Message Published " + MESSAGE_1);

            channel.basicPublish(DirectExchange.EXCHANGE_NAME, DirectExchange.ROUTING_KEY_2, null, MESSAGE_2.getBytes());
            System.out.println("Message Published " + MESSAGE_2);

            channel.basicPublish(DirectExchange.EXCHANGE_NAME, DirectExchange.ROUTING_KEY_3, null, MESSAGE_3.getBytes());
            System.out.println("Message Published " + MESSAGE_3);

            channel.basicPublish(DirectExchange.EXCHANGE_NAME, DirectExchange.ROUTING_KEY_3, null, "Message New".getBytes());
            System.out.println("Message Published " + "Message New");

            channel.close();
            connection.close();

        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }

}

///
Consumer Code:
package com.tata.amqp.exchange.direct;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;
import com.rabbitmq.client.Delivery;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class Consumer {
    public void receive() {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            //Callback for reading from Queue -1
            DeliverCallback consumer1 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From Queue - 1 : " + message);
            };
            channel.basicConsume(DirectExchange.QUEUE_NAME_1,true,consumer1,consumerTag -> {});

            //Callback for reading from Queue -2
            DeliverCallback consumer2 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From Queue - 2 : " + message);
            };
            channel.basicConsume(DirectExchange.QUEUE_NAME_2,true,consumer2,consumerTag -> {});

            //Callback for reading from Queue -3
            DeliverCallback consumer3 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From Queue - 3 : " + message);
            };
            channel.basicConsume(DirectExchange.QUEUE_NAME_3,true,consumer3,consumerTag -> {});


        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

Main App:

package com.tata.amqp.exchange.direct;

public class MainDirectApp {
    public static void main(String[] args) throws InterruptedException {
        //Create Exchange,Queues,Bindings will be ready
        DirectExchange directExchange = new DirectExchange();
        //Publish
        Producer producer = new Producer();
        producer.publish();

        //Consumer to read
        Consumer consumer = new Consumer();
        consumer.receive();

        Thread.sleep(1000);


    }
}
..............................................................................................					  Fanout Exchange
			     (Publisher and Subscriber)
                   Sending messages to many Subscribers/consumers at once
..............................................................................................

-A Fanout exchange is an exchange which routes messages the received message to all the queues
bound it.

-When the producer sends the message to fanout exchange, it copies the message and routes to all the queues that are bound to it.

-It just ignores the routing key or any pattern matching provided by the producer.

-It is really very usefull if you want to store messages in one or more queues.


Code:

1.Common Code : Please Refer the above Program

2.Exchange and Queue Creation.

package com.tata.amqp.exchange.fanout;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.ExchangeType;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;

public class FanoutExchange {
    //EXCHNAGE Name
    public static String EXCHANGE_NAME = "fanout-exchange";
    //Queues
    public static String QUEUE_NAME_1 = "fanout-queue-1";
    public static String QUEUE_NAME_2 = "fanout-queue-2";
    public static String QUEUE_NAME_3 = "fanout-queue-3";

    public static String ROUTING_KEY = "";

    public void createExchangeAndQueue() {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            //Create Exchange
            channel.exchangeDeclare(EXCHANGE_NAME, ExchangeType.FANOUT.getExchangeName(), true);

            //First Queue
            channel.queueDeclare(QUEUE_NAME_1, true, false, false, null);
            //Binding
            channel.queueBind(QUEUE_NAME_1, EXCHANGE_NAME, ROUTING_KEY);
            //Second Queue
            channel.queueDeclare(QUEUE_NAME_2, true, false, false, null);
            //binding
            channel.queueBind(QUEUE_NAME_2, EXCHANGE_NAME, ROUTING_KEY);

            //Third Queue
            channel.queueDeclare(QUEUE_NAME_3, true, false, false, null);
            // binding
            channel.queueBind(QUEUE_NAME_3, EXCHANGE_NAME, ROUTING_KEY);


        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


2.Producer

package com.tata.amqp.exchange.fanout;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.tata.amqp.basic.RabbitMQConnectionUtil;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class Producer {
    private static final String MESSAGE = "Happy News, Our Company got Ranked 1st  Position";

    public void publish() {
        try {
            Connection connection = RabbitMQConnectionUtil.getConnection();
            Channel channel = connection.createChannel();
            channel.basicPublish(FanoutExchange.EXCHANGE_NAME, FanoutExchange.ROUTING_KEY, null, MESSAGE.getBytes());
            System.out.println("Message Published " + MESSAGE);
            channel.close();
            connection.close();

        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }
}

3.Consumer
package com.tata.amqp.exchange.fanout;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.DeliverCallback;
import com.rabbitmq.client.Delivery;
import com.tata.amqp.basic.RabbitMQConnectionUtil;
import com.tata.amqp.exchange.direct.DirectExchange;

import java.io.IOException;

public class Consumer {
    public void receive() {
        Connection connection = RabbitMQConnectionUtil.getConnection();
        try {
            Channel channel = connection.createChannel();
            //Callback for reading from Queue -1
            DeliverCallback consumer1 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From" + FanoutExchange.QUEUE_NAME_1 + message);
            };
            channel.basicConsume(FanoutExchange.QUEUE_NAME_1,true,consumer1, consumerTag -> {});

            //Callback for reading from Queue -2
            DeliverCallback consumer2 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From" + FanoutExchange.QUEUE_NAME_2 + message);
            };
            channel.basicConsume(FanoutExchange.QUEUE_NAME_2,true,consumer2, consumerTag -> {});

            //Callback for reading from Queue -3
            DeliverCallback consumer3 = (String consumerTag, Delivery delivery) -> {
                //read message
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Got Message From" + FanoutExchange.QUEUE_NAME_3 + message);
            };
            channel.basicConsume(FanoutExchange.QUEUE_NAME_3,true,consumer3, consumerTag -> {});


        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

4.Main
package com.tata.amqp.exchange.fanout;

public class MainFanout {
    public static void main(String[] args) throws InterruptedException {
        //Create Exchange,Queues,Bindings will be ready
        FanoutExchange fanoutExchange = new FanoutExchange();
        //Publish
        Producer producer = new Producer();
        producer.publish();

        Consumer consumer = new Consumer();
        consumer.receive();

        Thread.sleep(1000);


    }
}
..............................................................................................


..............................................................................................
















  































				





